/* tslint:disable */
/* eslint-disable */
/*
SnapTrade

Connect brokerage accounts to your app for live positions and trading

The version of the OpenAPI document: 1.0.0
Contact: api@snaptrade.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccountOrderRecord } from '../models';
// @ts-ignore
import { ActionStrict } from '../models';
// @ts-ignore
import { ActionStrictWithOptions } from '../models';
// @ts-ignore
import { ManualTradeAndImpact } from '../models';
// @ts-ignore
import { ManualTradeForm } from '../models';
// @ts-ignore
import { ManualTradeFormNotionalValue } from '../models';
// @ts-ignore
import { ManualTradeFormWithOptions } from '../models';
// @ts-ignore
import { Model400FailedRequestResponse } from '../models';
// @ts-ignore
import { Model403FailedRequestResponse } from '../models';
// @ts-ignore
import { Model500UnexpectedExceptionResponse } from '../models';
// @ts-ignore
import { OrderTypeStrict } from '../models';
// @ts-ignore
import { SymbolsQuotesInner } from '../models';
// @ts-ignore
import { TimeInForceStrict } from '../models';
// @ts-ignore
import { TradingCancelUserAccountOrderRequest } from '../models';
// @ts-ignore
import { ValidatedTradeBody } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TradingApi - axios parameter creator
 * @export
 */
export const TradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected. 
         * @summary Cancel order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId 
         * @param {TradingCancelUserAccountOrderRequest} tradingCancelUserAccountOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelUserAccountOrder: async (userId: string, userSecret: string, accountId: string, tradingCancelUserAccountOrderRequest: TradingCancelUserAccountOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('cancelUserAccountOrder', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('cancelUserAccountOrder', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('cancelUserAccountOrder', 'accountId', accountId)
            // verify required parameter 'tradingCancelUserAccountOrderRequest' is not null or undefined
            assertParamExists('cancelUserAccountOrder', 'tradingCancelUserAccountOrderRequest', tradingCancelUserAccountOrderRequest)
            const localVarPath = `/accounts/{accountId}/orders/cancel`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject({object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration})
            // authentication PartnerSignature required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration })
            // authentication PartnerTimestamp required
            await setApiKeyToObject({object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration})
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: tradingCancelUserAccountOrderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/orders/cancel',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(tradingCancelUserAccountOrderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a `Trade` object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the `Trade` object returned expires after 5 minutes. Any order placed using an expired `Trade` will be rejected.
         * @summary Check order impact
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderImpact: async (userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getOrderImpact', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getOrderImpact', 'userSecret', userSecret)
            // verify required parameter 'manualTradeForm' is not null or undefined
            assertParamExists('getOrderImpact', 'manualTradeForm', manualTradeForm)
            const localVarPath = `/trade/impact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject({object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration})
            // authentication PartnerSignature required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration })
            // authentication PartnerTimestamp required
            await setApiKeyToObject({object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration})
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: manualTradeForm,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/trade/impact',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(manualTradeForm, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
         * @summary Get symbol quotes
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} symbols List of Universal Symbol IDs or tickers to get quotes for.
         * @param {string} accountId 
         * @param {boolean} [useTicker] Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountQuotes: async (userId: string, userSecret: string, symbols: string, accountId: string, useTicker?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAccountQuotes', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getUserAccountQuotes', 'userSecret', userSecret)
            // verify required parameter 'symbols' is not null or undefined
            assertParamExists('getUserAccountQuotes', 'symbols', symbols)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUserAccountQuotes', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/quotes`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject({object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration})
            // authentication PartnerSignature required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration })
            // authentication PartnerTimestamp required
            await setApiKeyToObject({object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration})
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (useTicker !== undefined) {
                localVarQueryParameter['use_ticker'] = useTicker;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/quotes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
         * @summary Place order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeFormWithOptions} manualTradeFormWithOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeForceOrder: async (userId: string, userSecret: string, manualTradeFormWithOptions: ManualTradeFormWithOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('placeForceOrder', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('placeForceOrder', 'userSecret', userSecret)
            // verify required parameter 'manualTradeFormWithOptions' is not null or undefined
            assertParamExists('placeForceOrder', 'manualTradeFormWithOptions', manualTradeFormWithOptions)
            const localVarPath = `/trade/place`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject({object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration})
            // authentication PartnerSignature required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration })
            // authentication PartnerTimestamp required
            await setApiKeyToObject({object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration})
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: manualTradeFormWithOptions,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/trade/place',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(manualTradeFormWithOptions, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Places the previously checked order with the brokerage. The `tradeId` is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
         * @summary Place checked order
         * @param {string} tradeId Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact)
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ValidatedTradeBody} [validatedTradeBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder: async (tradeId: string, userId: string, userSecret: string, validatedTradeBody?: ValidatedTradeBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('placeOrder', 'tradeId', tradeId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('placeOrder', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('placeOrder', 'userSecret', userSecret)
            const localVarPath = `/trade/{tradeId}`
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId !== undefined ? tradeId : `-tradeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject({object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration})
            // authentication PartnerSignature required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration })
            // authentication PartnerTimestamp required
            await setApiKeyToObject({object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration})
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: validatedTradeBody,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/trade/{tradeId}',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(validatedTradeBody, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingApi - functional programming interface
 * @export
 */
export const TradingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradingApiAxiosParamCreator(configuration)
    return {
        /**
         * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected. 
         * @summary Cancel order
         * @param {TradingApiCancelUserAccountOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelUserAccountOrder(requestParameters: TradingApiCancelUserAccountOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const tradingCancelUserAccountOrderRequest: TradingCancelUserAccountOrderRequest = {
                brokerage_order_id: requestParameters.brokerage_order_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelUserAccountOrder(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, tradingCancelUserAccountOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a `Trade` object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the `Trade` object returned expires after 5 minutes. Any order placed using an expired `Trade` will be rejected.
         * @summary Check order impact
         * @param {TradingApiGetOrderImpactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderImpact(requestParameters: TradingApiGetOrderImpactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualTradeAndImpact>> {
            const manualTradeForm: ManualTradeForm = {
                account_id: requestParameters.account_id,
                action: requestParameters.action,
                universal_symbol_id: requestParameters.universal_symbol_id,
                order_type: requestParameters.order_type,
                time_in_force: requestParameters.time_in_force,
                price: requestParameters.price,
                stop: requestParameters.stop,
                units: requestParameters.units,
                notional_value: requestParameters.notional_value
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderImpact(requestParameters.userId, requestParameters.userSecret, manualTradeForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
         * @summary Get symbol quotes
         * @param {TradingApiGetUserAccountQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccountQuotes(requestParameters: TradingApiGetUserAccountQuotesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SymbolsQuotesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccountQuotes(requestParameters.userId, requestParameters.userSecret, requestParameters.symbols, requestParameters.accountId, requestParameters.useTicker, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
         * @summary Place order
         * @param {TradingApiPlaceForceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeForceOrder(requestParameters: TradingApiPlaceForceOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const manualTradeFormWithOptions: ManualTradeFormWithOptions = {
                account_id: requestParameters.account_id,
                action: requestParameters.action,
                universal_symbol_id: requestParameters.universal_symbol_id,
                symbol: requestParameters.symbol,
                order_type: requestParameters.order_type,
                time_in_force: requestParameters.time_in_force,
                price: requestParameters.price,
                stop: requestParameters.stop,
                units: requestParameters.units,
                notional_value: requestParameters.notional_value
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeForceOrder(requestParameters.userId, requestParameters.userSecret, manualTradeFormWithOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Places the previously checked order with the brokerage. The `tradeId` is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
         * @summary Place checked order
         * @param {TradingApiPlaceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeOrder(requestParameters: TradingApiPlaceOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const validatedTradeBody: ValidatedTradeBody = {
                wait_to_confirm: requestParameters.wait_to_confirm
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeOrder(requestParameters.tradeId, requestParameters.userId, requestParameters.userSecret, validatedTradeBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradingApi - factory interface
 * @export
 */
export const TradingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradingApiFp(configuration)
    return {
        /**
         * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected. 
         * @summary Cancel order
         * @param {TradingApiCancelUserAccountOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelUserAccountOrder(requestParameters: TradingApiCancelUserAccountOrderRequest, options?: AxiosRequestConfig): AxiosPromise<AccountOrderRecord> {
            return localVarFp.cancelUserAccountOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a `Trade` object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the `Trade` object returned expires after 5 minutes. Any order placed using an expired `Trade` will be rejected.
         * @summary Check order impact
         * @param {TradingApiGetOrderImpactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderImpact(requestParameters: TradingApiGetOrderImpactRequest, options?: AxiosRequestConfig): AxiosPromise<ManualTradeAndImpact> {
            return localVarFp.getOrderImpact(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
         * @summary Get symbol quotes
         * @param {TradingApiGetUserAccountQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountQuotes(requestParameters: TradingApiGetUserAccountQuotesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SymbolsQuotesInner>> {
            return localVarFp.getUserAccountQuotes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
         * @summary Place order
         * @param {TradingApiPlaceForceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeForceOrder(requestParameters: TradingApiPlaceForceOrderRequest, options?: AxiosRequestConfig): AxiosPromise<AccountOrderRecord> {
            return localVarFp.placeForceOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Places the previously checked order with the brokerage. The `tradeId` is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
         * @summary Place checked order
         * @param {TradingApiPlaceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(requestParameters: TradingApiPlaceOrderRequest, options?: AxiosRequestConfig): AxiosPromise<AccountOrderRecord> {
            return localVarFp.placeOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelUserAccountOrder operation in TradingApi.
 * @export
 * @interface TradingApiCancelUserAccountOrderRequest
 */
export type TradingApiCancelUserAccountOrderRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiCancelUserAccountOrder
    */
    readonly userId: string
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiCancelUserAccountOrder
    */
    readonly userSecret: string
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiCancelUserAccountOrder
    */
    readonly accountId: string
    
} & TradingCancelUserAccountOrderRequest

/**
 * Request parameters for getOrderImpact operation in TradingApi.
 * @export
 * @interface TradingApiGetOrderImpactRequest
 */
export type TradingApiGetOrderImpactRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiGetOrderImpact
    */
    readonly userId: string
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiGetOrderImpact
    */
    readonly userSecret: string
    
} & ManualTradeForm

/**
 * Request parameters for getUserAccountQuotes operation in TradingApi.
 * @export
 * @interface TradingApiGetUserAccountQuotesRequest
 */
export type TradingApiGetUserAccountQuotesRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiGetUserAccountQuotes
    */
    readonly userId: string
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiGetUserAccountQuotes
    */
    readonly userSecret: string
    
    /**
    * List of Universal Symbol IDs or tickers to get quotes for.
    * @type {string}
    * @memberof TradingApiGetUserAccountQuotes
    */
    readonly symbols: string
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiGetUserAccountQuotes
    */
    readonly accountId: string
    
    /**
    * Should be set to `True` if `symbols` are comprised of tickers. Defaults to `False` if not provided.
    * @type {boolean}
    * @memberof TradingApiGetUserAccountQuotes
    */
    readonly useTicker?: boolean
    
}

/**
 * Request parameters for placeForceOrder operation in TradingApi.
 * @export
 * @interface TradingApiPlaceForceOrderRequest
 */
export type TradingApiPlaceForceOrderRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiPlaceForceOrder
    */
    readonly userId: string
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiPlaceForceOrder
    */
    readonly userSecret: string
    
} & ManualTradeFormWithOptions

/**
 * Request parameters for placeOrder operation in TradingApi.
 * @export
 * @interface TradingApiPlaceOrderRequest
 */
export type TradingApiPlaceOrderRequest = {
    
    /**
    * Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact)
    * @type {string}
    * @memberof TradingApiPlaceOrder
    */
    readonly tradeId: string
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiPlaceOrder
    */
    readonly userId: string
    
    /**
    * 
    * @type {string}
    * @memberof TradingApiPlaceOrder
    */
    readonly userSecret: string
    
} & ValidatedTradeBody

/**
 * TradingApiGenerated - object-oriented interface
 * @export
 * @class TradingApiGenerated
 * @extends {BaseAPI}
 */
export class TradingApiGenerated extends BaseAPI {
    /**
     * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected. 
     * @summary Cancel order
     * @param {TradingApiCancelUserAccountOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    public cancelUserAccountOrder(requestParameters: TradingApiCancelUserAccountOrderRequest, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).cancelUserAccountOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a `Trade` object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the `Trade` object returned expires after 5 minutes. Any order placed using an expired `Trade` will be rejected.
     * @summary Check order impact
     * @param {TradingApiGetOrderImpactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    public getOrderImpact(requestParameters: TradingApiGetOrderImpactRequest, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).getOrderImpact(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     * @summary Get symbol quotes
     * @param {TradingApiGetUserAccountQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    public getUserAccountQuotes(requestParameters: TradingApiGetUserAccountQuotesRequest, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).getUserAccountQuotes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
     * @summary Place order
     * @param {TradingApiPlaceForceOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    public placeForceOrder(requestParameters: TradingApiPlaceForceOrderRequest, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).placeForceOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Places the previously checked order with the brokerage. The `tradeId` is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
     * @summary Place checked order
     * @param {TradingApiPlaceOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    public placeOrder(requestParameters: TradingApiPlaceOrderRequest, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).placeOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
