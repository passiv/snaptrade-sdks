/*
 * SnapTrade
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.AccountUniversalActivityCurrency;
import com.konfigthis.client.model.OptionsSymbolNullable;
import com.konfigthis.client.model.SymbolNullable;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * A transaction or activity from an institution
 */
@ApiModel(description = "A transaction or activity from an institution")@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class AccountUniversalActivity {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_SYMBOL = "symbol";
  @SerializedName(SERIALIZED_NAME_SYMBOL)
  private SymbolNullable symbol;

  public static final String SERIALIZED_NAME_OPTION_SYMBOL = "option_symbol";
  @SerializedName(SERIALIZED_NAME_OPTION_SYMBOL)
  private OptionsSymbolNullable optionSymbol;

  public static final String SERIALIZED_NAME_PRICE = "price";
  @SerializedName(SERIALIZED_NAME_PRICE)
  private Double price;

  public static final String SERIALIZED_NAME_UNITS = "units";
  @SerializedName(SERIALIZED_NAME_UNITS)
  private Double units;

  public static final String SERIALIZED_NAME_AMOUNT = "amount";
  @SerializedName(SERIALIZED_NAME_AMOUNT)
  private Double amount;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private AccountUniversalActivityCurrency currency;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_OPTION_TYPE = "option_type";
  @SerializedName(SERIALIZED_NAME_OPTION_TYPE)
  private String optionType;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_TRADE_DATE = "trade_date";
  @SerializedName(SERIALIZED_NAME_TRADE_DATE)
  private OffsetDateTime tradeDate;

  public static final String SERIALIZED_NAME_SETTLEMENT_DATE = "settlement_date";
  @SerializedName(SERIALIZED_NAME_SETTLEMENT_DATE)
  private OffsetDateTime settlementDate;

  public static final String SERIALIZED_NAME_FEE = "fee";
  @SerializedName(SERIALIZED_NAME_FEE)
  private Double fee;

  public static final String SERIALIZED_NAME_FX_RATE = "fx_rate";
  @SerializedName(SERIALIZED_NAME_FX_RATE)
  private Double fxRate;

  public static final String SERIALIZED_NAME_INSTITUTION = "institution";
  @SerializedName(SERIALIZED_NAME_INSTITUTION)
  private String institution;

  public static final String SERIALIZED_NAME_EXTERNAL_REFERENCE_ID = "external_reference_id";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_REFERENCE_ID)
  private String externalReferenceId;

  public AccountUniversalActivity() {
  }

  public AccountUniversalActivity id(String id) {
    
    
    
    
    this.id = id;
    return this;
  }

   /**
   * Unique identifier for the transaction. This is the ID used to reference the transaction in SnapTrade.  Please note that this ID _can_ change if the transaction is deleted and re-added. Under normal circumstances, SnapTrade does not delete transactions. The only time this would happen is if SnapTrade re-fetches and reprocesses the data from the brokerage, which is rare. If you require a stable ID, please let us know and we can work with you to provide one. 
   * @return id
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2f7dc9b3-5c33-4668-3440-2b31e056ebe6", value = "Unique identifier for the transaction. This is the ID used to reference the transaction in SnapTrade.  Please note that this ID _can_ change if the transaction is deleted and re-added. Under normal circumstances, SnapTrade does not delete transactions. The only time this would happen is if SnapTrade re-fetches and reprocesses the data from the brokerage, which is rare. If you require a stable ID, please let us know and we can work with you to provide one. ")

  public String getId() {
    return id;
  }


  public void setId(String id) {
    
    
    
    this.id = id;
  }


  public AccountUniversalActivity symbol(SymbolNullable symbol) {
    
    
    
    
    this.symbol = symbol;
    return this;
  }

   /**
   * Get symbol
   * @return symbol
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public SymbolNullable getSymbol() {
    return symbol;
  }


  public void setSymbol(SymbolNullable symbol) {
    
    
    
    this.symbol = symbol;
  }


  public AccountUniversalActivity optionSymbol(OptionsSymbolNullable optionSymbol) {
    
    
    
    
    this.optionSymbol = optionSymbol;
    return this;
  }

   /**
   * Get optionSymbol
   * @return optionSymbol
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public OptionsSymbolNullable getOptionSymbol() {
    return optionSymbol;
  }


  public void setOptionSymbol(OptionsSymbolNullable optionSymbol) {
    
    
    
    this.optionSymbol = optionSymbol;
  }


  public AccountUniversalActivity price(Double price) {
    
    
    
    
    this.price = price;
    return this;
  }

  public AccountUniversalActivity price(Integer price) {
    
    
    
    
    this.price = price.doubleValue();
    return this;
  }

   /**
   * The price of the security for the transaction. This is mostly applicable to &#x60;BUY&#x60;, &#x60;SELL&#x60;, and &#x60;DIVIDEND&#x60; transactions.
   * @return price
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "0.4", value = "The price of the security for the transaction. This is mostly applicable to `BUY`, `SELL`, and `DIVIDEND` transactions.")

  public Double getPrice() {
    return price;
  }


  public void setPrice(Double price) {
    
    
    
    this.price = price;
  }


  public AccountUniversalActivity units(Double units) {
    
    
    
    
    this.units = units;
    return this;
  }

  public AccountUniversalActivity units(Integer units) {
    
    
    
    
    this.units = units.doubleValue();
    return this;
  }

   /**
   * The number of units of the security for the transaction. This is mostly applicable to &#x60;BUY&#x60;, &#x60;SELL&#x60;, and &#x60;DIVIDEND&#x60; transactions.
   * @return units
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "5.2", value = "The number of units of the security for the transaction. This is mostly applicable to `BUY`, `SELL`, and `DIVIDEND` transactions.")

  public Double getUnits() {
    return units;
  }


  public void setUnits(Double units) {
    
    
    
    this.units = units;
  }


  public AccountUniversalActivity amount(Double amount) {
    
    
    
    
    this.amount = amount;
    return this;
  }

  public AccountUniversalActivity amount(Integer amount) {
    
    
    
    
    this.amount = amount.doubleValue();
    return this;
  }

   /**
   * The amount of the transaction denominated in &#x60;currency&#x60;. This can be positive or negative. In general, transactions that positively affect the account balance (like sell, deposits, dividends, etc) will have a positive amount, while transactions that negatively affect the account balance (like buy, withdrawals, fees, etc) will have a negative amount.
   * @return amount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "263.82", value = "The amount of the transaction denominated in `currency`. This can be positive or negative. In general, transactions that positively affect the account balance (like sell, deposits, dividends, etc) will have a positive amount, while transactions that negatively affect the account balance (like buy, withdrawals, fees, etc) will have a negative amount.")

  public Double getAmount() {
    return amount;
  }


  public void setAmount(Double amount) {
    
    
    
    this.amount = amount;
  }


  public AccountUniversalActivity currency(AccountUniversalActivityCurrency currency) {
    
    
    
    
    this.currency = currency;
    return this;
  }

   /**
   * Get currency
   * @return currency
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public AccountUniversalActivityCurrency getCurrency() {
    return currency;
  }


  public void setCurrency(AccountUniversalActivityCurrency currency) {
    
    
    
    this.currency = currency;
  }


  public AccountUniversalActivity type(String type) {
    
    
    
    
    this.type = type;
    return this;
  }

   /**
   * A string representing the type of transaction. SnapTrade does a best effort to categorize the brokerage transaction types into a common set of values. Here are some of the most popular values:   - &#x60;BUY&#x60; - Asset bought.   - &#x60;SELL&#x60; - Asset sold.   - &#x60;DIVIDEND&#x60; - Dividend payout.   - &#x60;CONTRIBUTION&#x60; - Cash contribution.   - &#x60;WITHDRAWAL&#x60; - Cash withdrawal.   - &#x60;REI&#x60; - Dividend reinvestment.   - &#x60;STOCK_DIVIDEND&#x60; - A type of dividend where a company distributes shares instead of cash   - &#x60;INTEREST&#x60; - Interest deposited into the account.   - &#x60;FEE&#x60; - Fee withdrawn from the account.   - &#x60;TAX&#x60;&#x60; - A tax related fee.   - &#x60;OPTIONEXPIRATION&#x60; - Option expiration event.   - &#x60;OPTIONASSIGNMENT&#x60; - Option assignment event.   - &#x60;OPTIONEXERCISE&#x60; - Option exercise event.   - &#x60;TRANSFER&#x60; - Transfer of assets from one account to another.   - &#x60;SPLIT&#x60; - A stock share split. 
   * @return type
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "BUY", value = "A string representing the type of transaction. SnapTrade does a best effort to categorize the brokerage transaction types into a common set of values. Here are some of the most popular values:   - `BUY` - Asset bought.   - `SELL` - Asset sold.   - `DIVIDEND` - Dividend payout.   - `CONTRIBUTION` - Cash contribution.   - `WITHDRAWAL` - Cash withdrawal.   - `REI` - Dividend reinvestment.   - `STOCK_DIVIDEND` - A type of dividend where a company distributes shares instead of cash   - `INTEREST` - Interest deposited into the account.   - `FEE` - Fee withdrawn from the account.   - `TAX`` - A tax related fee.   - `OPTIONEXPIRATION` - Option expiration event.   - `OPTIONASSIGNMENT` - Option assignment event.   - `OPTIONEXERCISE` - Option exercise event.   - `TRANSFER` - Transfer of assets from one account to another.   - `SPLIT` - A stock share split. ")

  public String getType() {
    return type;
  }


  public void setType(String type) {
    
    
    
    this.type = type;
  }


  public AccountUniversalActivity optionType(String optionType) {
    
    
    
    
    this.optionType = optionType;
    return this;
  }

   /**
   * If an option &#x60;BUY&#x60; or &#x60;SELL&#x60; transaction, this further specifies the type of action. The possible values are: - BUY_TO_OPEN - BUY_TO_CLOSE - SELL_TO_OPEN - SELL_TO_CLOSE 
   * @return optionType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "BUY_TO_OPEN", value = "If an option `BUY` or `SELL` transaction, this further specifies the type of action. The possible values are: - BUY_TO_OPEN - BUY_TO_CLOSE - SELL_TO_OPEN - SELL_TO_CLOSE ")

  public String getOptionType() {
    return optionType;
  }


  public void setOptionType(String optionType) {
    
    
    
    this.optionType = optionType;
  }


  public AccountUniversalActivity description(String description) {
    
    
    
    
    this.description = description;
    return this;
  }

   /**
   * A human-readable description of the transaction. This is usually the brokerage&#39;s description of the transaction.
   * @return description
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "WALT DISNEY UNIT DIST ON 21 SHS REC 12/31/21 PAY 01/06/22", value = "A human-readable description of the transaction. This is usually the brokerage's description of the transaction.")

  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    
    
    
    this.description = description;
  }


  public AccountUniversalActivity tradeDate(OffsetDateTime tradeDate) {
    
    
    
    
    this.tradeDate = tradeDate;
    return this;
  }

   /**
   * The recorded time for the transaction. The granularity of this timestamp depends on the brokerage. Some brokerages provide the exact time of the transaction, while others provide only the date. Please check the [integrations page](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v&#x3D;6fab8012ade6441fa0c6d9af9c55ce3a) for the specific brokerage to see the granularity of the timestamps. Note that even though the field is named &#x60;trade_date&#x60;, it can represent any type of transaction, not just trades.
   * @return tradeDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2024-03-22T16:27:55Z", value = "The recorded time for the transaction. The granularity of this timestamp depends on the brokerage. Some brokerages provide the exact time of the transaction, while others provide only the date. Please check the [integrations page](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=6fab8012ade6441fa0c6d9af9c55ce3a) for the specific brokerage to see the granularity of the timestamps. Note that even though the field is named `trade_date`, it can represent any type of transaction, not just trades.")

  public OffsetDateTime getTradeDate() {
    return tradeDate;
  }


  public void setTradeDate(OffsetDateTime tradeDate) {
    
    
    
    this.tradeDate = tradeDate;
  }


  public AccountUniversalActivity settlementDate(OffsetDateTime settlementDate) {
    
    
    
    
    this.settlementDate = settlementDate;
    return this;
  }

   /**
   * The date on which the transaction is settled.
   * @return settlementDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2024-03-26T00:00Z", value = "The date on which the transaction is settled.")

  public OffsetDateTime getSettlementDate() {
    return settlementDate;
  }


  public void setSettlementDate(OffsetDateTime settlementDate) {
    
    
    
    this.settlementDate = settlementDate;
  }


  public AccountUniversalActivity fee(Double fee) {
    
    
    
    
    this.fee = fee;
    return this;
  }

  public AccountUniversalActivity fee(Integer fee) {
    
    
    
    
    this.fee = fee.doubleValue();
    return this;
  }

   /**
   * Any fee associated with the transaction if provided by the brokerage.
   * @return fee
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "0", value = "Any fee associated with the transaction if provided by the brokerage.")

  public Double getFee() {
    return fee;
  }


  public void setFee(Double fee) {
    
    
    
    this.fee = fee;
  }


  public AccountUniversalActivity fxRate(Double fxRate) {
    
    
    
    
    this.fxRate = fxRate;
    return this;
  }

  public AccountUniversalActivity fxRate(Integer fxRate) {
    
    
    
    
    this.fxRate = fxRate.doubleValue();
    return this;
  }

   /**
   * The forex conversion rate involved in the transaction if provided by the brokerage. Used in cases where securities of one currency are purchased in a different currency, and the forex conversion is automatic. In those cases, price, amount and fee will be in the top level currency (activity -&gt; currency)
   * @return fxRate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "1.032", value = "The forex conversion rate involved in the transaction if provided by the brokerage. Used in cases where securities of one currency are purchased in a different currency, and the forex conversion is automatic. In those cases, price, amount and fee will be in the top level currency (activity -> currency)")

  public Double getFxRate() {
    return fxRate;
  }


  public void setFxRate(Double fxRate) {
    
    
    
    this.fxRate = fxRate;
  }


  public AccountUniversalActivity institution(String institution) {
    
    
    
    
    this.institution = institution;
    return this;
  }

   /**
   * The institution that the transaction is associated with. This is usually the brokerage name.
   * @return institution
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "Robinhood", value = "The institution that the transaction is associated with. This is usually the brokerage name.")

  public String getInstitution() {
    return institution;
  }


  public void setInstitution(String institution) {
    
    
    
    this.institution = institution;
  }


  public AccountUniversalActivity externalReferenceId(String externalReferenceId) {
    
    
    
    
    this.externalReferenceId = externalReferenceId;
    return this;
  }

   /**
   * Reference ID from brokerage used to identify related transactions. For example if an order comprises of several transactions (buy, fee, fx), they can be grouped if they share the same &#x60;external_reference_id&#x60;
   * @return externalReferenceId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2f7dc9b3-5c33-4668-3440-2b31e056ebe6", value = "Reference ID from brokerage used to identify related transactions. For example if an order comprises of several transactions (buy, fee, fx), they can be grouped if they share the same `external_reference_id`")

  public String getExternalReferenceId() {
    return externalReferenceId;
  }


  public void setExternalReferenceId(String externalReferenceId) {
    
    
    
    this.externalReferenceId = externalReferenceId;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the AccountUniversalActivity instance itself
   */
  public AccountUniversalActivity putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AccountUniversalActivity accountUniversalActivity = (AccountUniversalActivity) o;
    return Objects.equals(this.id, accountUniversalActivity.id) &&
        Objects.equals(this.symbol, accountUniversalActivity.symbol) &&
        Objects.equals(this.optionSymbol, accountUniversalActivity.optionSymbol) &&
        Objects.equals(this.price, accountUniversalActivity.price) &&
        Objects.equals(this.units, accountUniversalActivity.units) &&
        Objects.equals(this.amount, accountUniversalActivity.amount) &&
        Objects.equals(this.currency, accountUniversalActivity.currency) &&
        Objects.equals(this.type, accountUniversalActivity.type) &&
        Objects.equals(this.optionType, accountUniversalActivity.optionType) &&
        Objects.equals(this.description, accountUniversalActivity.description) &&
        Objects.equals(this.tradeDate, accountUniversalActivity.tradeDate) &&
        Objects.equals(this.settlementDate, accountUniversalActivity.settlementDate) &&
        Objects.equals(this.fee, accountUniversalActivity.fee) &&
        Objects.equals(this.fxRate, accountUniversalActivity.fxRate) &&
        Objects.equals(this.institution, accountUniversalActivity.institution) &&
        Objects.equals(this.externalReferenceId, accountUniversalActivity.externalReferenceId)&&
        Objects.equals(this.additionalProperties, accountUniversalActivity.additionalProperties);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, symbol, optionSymbol, price, units, amount, currency, type, optionType, description, tradeDate, settlementDate, fee, fxRate, institution, externalReferenceId, additionalProperties);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AccountUniversalActivity {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
    sb.append("    optionSymbol: ").append(toIndentedString(optionSymbol)).append("\n");
    sb.append("    price: ").append(toIndentedString(price)).append("\n");
    sb.append("    units: ").append(toIndentedString(units)).append("\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    optionType: ").append(toIndentedString(optionType)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    tradeDate: ").append(toIndentedString(tradeDate)).append("\n");
    sb.append("    settlementDate: ").append(toIndentedString(settlementDate)).append("\n");
    sb.append("    fee: ").append(toIndentedString(fee)).append("\n");
    sb.append("    fxRate: ").append(toIndentedString(fxRate)).append("\n");
    sb.append("    institution: ").append(toIndentedString(institution)).append("\n");
    sb.append("    externalReferenceId: ").append(toIndentedString(externalReferenceId)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("symbol");
    openapiFields.add("option_symbol");
    openapiFields.add("price");
    openapiFields.add("units");
    openapiFields.add("amount");
    openapiFields.add("currency");
    openapiFields.add("type");
    openapiFields.add("option_type");
    openapiFields.add("description");
    openapiFields.add("trade_date");
    openapiFields.add("settlement_date");
    openapiFields.add("fee");
    openapiFields.add("fx_rate");
    openapiFields.add("institution");
    openapiFields.add("external_reference_id");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AccountUniversalActivity
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!AccountUniversalActivity.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AccountUniversalActivity is not found in the empty JSON string", AccountUniversalActivity.openapiRequiredFields.toString()));
        }
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `symbol`
      if (jsonObj.get("symbol") != null && !jsonObj.get("symbol").isJsonNull()) {
        SymbolNullable.validateJsonObject(jsonObj.getAsJsonObject("symbol"));
      }
      // validate the optional field `option_symbol`
      if (jsonObj.get("option_symbol") != null && !jsonObj.get("option_symbol").isJsonNull()) {
        OptionsSymbolNullable.validateJsonObject(jsonObj.getAsJsonObject("option_symbol"));
      }
      // validate the optional field `currency`
      if (jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) {
        AccountUniversalActivityCurrency.validateJsonObject(jsonObj.getAsJsonObject("currency"));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      if ((jsonObj.get("option_type") != null && !jsonObj.get("option_type").isJsonNull()) && !jsonObj.get("option_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `option_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("option_type").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("institution") != null && !jsonObj.get("institution").isJsonNull()) && !jsonObj.get("institution").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `institution` to be a primitive type in the JSON string but got `%s`", jsonObj.get("institution").toString()));
      }
      if (!jsonObj.get("external_reference_id").isJsonNull() && (jsonObj.get("external_reference_id") != null && !jsonObj.get("external_reference_id").isJsonNull()) && !jsonObj.get("external_reference_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `external_reference_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("external_reference_id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AccountUniversalActivity.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AccountUniversalActivity' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AccountUniversalActivity> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AccountUniversalActivity.class));

       return (TypeAdapter<T>) new TypeAdapter<AccountUniversalActivity>() {
           @Override
           public void write(JsonWriter out, AccountUniversalActivity value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else if (entry.getValue() == null) {
                   obj.addProperty(entry.getKey(), (String) null);
                 } else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public AccountUniversalActivity read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             AccountUniversalActivity instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AccountUniversalActivity given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AccountUniversalActivity
  * @throws IOException if the JSON string is invalid with respect to AccountUniversalActivity
  */
  public static AccountUniversalActivity fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AccountUniversalActivity.class);
  }

 /**
  * Convert an instance of AccountUniversalActivity to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

