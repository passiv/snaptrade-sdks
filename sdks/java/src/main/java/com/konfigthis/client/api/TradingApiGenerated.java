/*
 * SnapTrade
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.AccountInformationGetUserAccountOrderDetailRequest;
import com.konfigthis.client.model.AccountOrderRecord;
import com.konfigthis.client.model.ActionStrict;
import com.konfigthis.client.model.ActionStrictWithOptions;
import java.math.BigDecimal;
import com.konfigthis.client.model.CancelOrderResponse;
import com.konfigthis.client.model.CryptoOrderForm;
import com.konfigthis.client.model.CryptoOrderPreview;
import com.konfigthis.client.model.CryptoTradingInstrument;
import com.konfigthis.client.model.CryptocurrencyPairQuote;
import com.konfigthis.client.model.ManualTradeAndImpact;
import com.konfigthis.client.model.ManualTradeForm;
import com.konfigthis.client.model.ManualTradeFormBracket;
import com.konfigthis.client.model.ManualTradeFormWithOptions;
import com.konfigthis.client.model.ManualTradeReplaceForm;
import com.konfigthis.client.model.MlegLeg;
import com.konfigthis.client.model.MlegOrderResponse;
import com.konfigthis.client.model.MlegOrderTypeStrict;
import com.konfigthis.client.model.MlegPriceEffectStrictNullable;
import com.konfigthis.client.model.MlegTradeForm;
import java.time.OffsetDateTime;
import com.konfigthis.client.model.OrderTypeStrict;
import com.konfigthis.client.model.OrderUpdatedResponse;
import com.konfigthis.client.model.StopLoss;
import com.konfigthis.client.model.SymbolsQuotesInner;
import com.konfigthis.client.model.TakeProfit;
import com.konfigthis.client.model.TimeInForceStrict;
import com.konfigthis.client.model.TradingInstrument;
import com.konfigthis.client.model.TradingSearchCryptocurrencyPairInstruments200Response;
import java.util.UUID;
import com.konfigthis.client.model.ValidatedTradeBody;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class TradingApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TradingApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public TradingApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call cancelOrderCall(String userId, String userSecret, UUID accountId, AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = accountInformationGetUserAccountOrderDetailRequest;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/trading/cancel"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelOrderValidateBeforeCall(String userId, String userSecret, UUID accountId, AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling cancelOrder(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling cancelOrder(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cancelOrder(Async)");
        }

        // verify the required parameter 'accountInformationGetUserAccountOrderDetailRequest' is set
        if (accountInformationGetUserAccountOrderDetailRequest == null) {
            throw new ApiException("Missing the required parameter 'accountInformationGetUserAccountOrderDetailRequest' when calling cancelOrder(Async)");
        }

        return cancelOrderCall(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, _callback);

    }


    private ApiResponse<CancelOrderResponse> cancelOrderWithHttpInfo(String userId, String userSecret, UUID accountId, AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest) throws ApiException {
        okhttp3.Call localVarCall = cancelOrderValidateBeforeCall(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, null);
        Type localVarReturnType = new TypeToken<CancelOrderResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call cancelOrderAsync(String userId, String userSecret, UUID accountId, AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest, final ApiCallback<CancelOrderResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = cancelOrderValidateBeforeCall(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, _callback);
        Type localVarReturnType = new TypeToken<CancelOrderResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class CancelOrderRequestBuilderGenerated {
        final String brokerageOrderId;
        final String userId;
        final String userSecret;
        final UUID accountId;

        public CancelOrderRequestBuilderGenerated(String brokerageOrderId, String userId, String userSecret, UUID accountId) {
            this.brokerageOrderId = brokerageOrderId;
            this.userId = userId;
            this.userSecret = userSecret;
            this.accountId = accountId;
        }

        /**
         * Build call for cancelOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = buildBodyParams();
            return cancelOrderCall(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, _callback);
        }

        private AccountInformationGetUserAccountOrderDetailRequest buildBodyParams() {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = new AccountInformationGetUserAccountOrderDetailRequest();
            accountInformationGetUserAccountOrderDetailRequest.brokerageOrderId(this.brokerageOrderId);
            return accountInformationGetUserAccountOrderDetailRequest;
        }

        /**
         * Execute cancelOrder request
         * @return CancelOrderResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public CancelOrderResponse execute() throws ApiException {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = buildBodyParams();
            ApiResponse<CancelOrderResponse> localVarResp = cancelOrderWithHttpInfo(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute cancelOrder request with HTTP info returned
         * @return ApiResponse&lt;CancelOrderResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<CancelOrderResponse> executeWithHttpInfo() throws ApiException {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = buildBodyParams();
            return cancelOrderWithHttpInfo(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest);
        }

        /**
         * Execute cancelOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<CancelOrderResponse> _callback) throws ApiException {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = buildBodyParams();
            return cancelOrderAsync(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, _callback);
        }
    }

    /**
     * Cancel order
     * Cancels an order in the specified account. Accepts order IDs for all asset types. 
     * @param userId  (required)
     * @param userSecret  (required)
     * @param accountId  (required)
     * @param accountInformationGetUserAccountOrderDetailRequest  (required)
     * @return CancelOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.CancelOrderRequestBuilder cancelOrder(String brokerageOrderId, String userId, String userSecret, UUID accountId) throws IllegalArgumentException {
        if (brokerageOrderId == null) throw new IllegalArgumentException("\"brokerageOrderId\" is required but got null");
            

        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        return ((TradingApi) this).new CancelOrderRequestBuilder(brokerageOrderId, userId, userSecret, accountId);
    }
    private okhttp3.Call cancelUserAccountOrderCall(String userId, String userSecret, UUID accountId, AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = accountInformationGetUserAccountOrderDetailRequest;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/orders/cancel"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelUserAccountOrderValidateBeforeCall(String userId, String userSecret, UUID accountId, AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling cancelUserAccountOrder(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling cancelUserAccountOrder(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cancelUserAccountOrder(Async)");
        }

        // verify the required parameter 'accountInformationGetUserAccountOrderDetailRequest' is set
        if (accountInformationGetUserAccountOrderDetailRequest == null) {
            throw new ApiException("Missing the required parameter 'accountInformationGetUserAccountOrderDetailRequest' when calling cancelUserAccountOrder(Async)");
        }

        return cancelUserAccountOrderCall(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, _callback);

    }


    private ApiResponse<AccountOrderRecord> cancelUserAccountOrderWithHttpInfo(String userId, String userSecret, UUID accountId, AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest) throws ApiException {
        okhttp3.Call localVarCall = cancelUserAccountOrderValidateBeforeCall(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, null);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call cancelUserAccountOrderAsync(String userId, String userSecret, UUID accountId, AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest, final ApiCallback<AccountOrderRecord> _callback) throws ApiException {

        okhttp3.Call localVarCall = cancelUserAccountOrderValidateBeforeCall(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, _callback);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class CancelUserAccountOrderRequestBuilderGenerated {
        final String brokerageOrderId;
        final String userId;
        final String userSecret;
        final UUID accountId;

        public CancelUserAccountOrderRequestBuilderGenerated(String brokerageOrderId, String userId, String userSecret, UUID accountId) {
            this.brokerageOrderId = brokerageOrderId;
            this.userId = userId;
            this.userSecret = userSecret;
            this.accountId = accountId;
        }

        /**
         * Build call for cancelUserAccountOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Order Record of canceled order </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = buildBodyParams();
            return cancelUserAccountOrderCall(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, _callback);
        }

        private AccountInformationGetUserAccountOrderDetailRequest buildBodyParams() {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = new AccountInformationGetUserAccountOrderDetailRequest();
            accountInformationGetUserAccountOrderDetailRequest.brokerageOrderId(this.brokerageOrderId);
            return accountInformationGetUserAccountOrderDetailRequest;
        }

        /**
         * Execute cancelUserAccountOrder request
         * @return AccountOrderRecord
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Order Record of canceled order </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public AccountOrderRecord execute() throws ApiException {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = buildBodyParams();
            ApiResponse<AccountOrderRecord> localVarResp = cancelUserAccountOrderWithHttpInfo(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute cancelUserAccountOrder request with HTTP info returned
         * @return ApiResponse&lt;AccountOrderRecord&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Order Record of canceled order </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<AccountOrderRecord> executeWithHttpInfo() throws ApiException {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = buildBodyParams();
            return cancelUserAccountOrderWithHttpInfo(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest);
        }

        /**
         * Execute cancelUserAccountOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Order Record of canceled order </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<AccountOrderRecord> _callback) throws ApiException {
            AccountInformationGetUserAccountOrderDetailRequest accountInformationGetUserAccountOrderDetailRequest = buildBodyParams();
            return cancelUserAccountOrderAsync(userId, userSecret, accountId, accountInformationGetUserAccountOrderDetailRequest, _callback);
        }
    }

    /**
     * Cancel equity order
     * **This endpoint is deprecated. Please switch to [the new cancel order endpoint](/reference/Trading/Trading_cancelOrder) ** Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected. 
     * @param userId  (required)
     * @param userSecret  (required)
     * @param accountId  (required)
     * @param accountInformationGetUserAccountOrderDetailRequest  (required)
     * @return CancelUserAccountOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order Record of canceled order </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public TradingApi.CancelUserAccountOrderRequestBuilder cancelUserAccountOrder(String brokerageOrderId, String userId, String userSecret, UUID accountId) throws IllegalArgumentException {
        if (brokerageOrderId == null) throw new IllegalArgumentException("\"brokerageOrderId\" is required but got null");
            

        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        return ((TradingApi) this).new CancelUserAccountOrderRequestBuilder(brokerageOrderId, userId, userSecret, accountId);
    }
    private okhttp3.Call getCryptocurrencyPairQuoteCall(String userId, String userSecret, UUID accountId, String instrumentSymbol, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/trading/instruments/cryptocurrencyPairs/{instrumentSymbol}/quote"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()))
            .replace("{" + "instrumentSymbol" + "}", localVarApiClient.escapeString(instrumentSymbol.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCryptocurrencyPairQuoteValidateBeforeCall(String userId, String userSecret, UUID accountId, String instrumentSymbol, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getCryptocurrencyPairQuote(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling getCryptocurrencyPairQuote(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling getCryptocurrencyPairQuote(Async)");
        }

        // verify the required parameter 'instrumentSymbol' is set
        if (instrumentSymbol == null) {
            throw new ApiException("Missing the required parameter 'instrumentSymbol' when calling getCryptocurrencyPairQuote(Async)");
        }

        return getCryptocurrencyPairQuoteCall(userId, userSecret, accountId, instrumentSymbol, _callback);

    }


    private ApiResponse<CryptocurrencyPairQuote> getCryptocurrencyPairQuoteWithHttpInfo(String userId, String userSecret, UUID accountId, String instrumentSymbol) throws ApiException {
        okhttp3.Call localVarCall = getCryptocurrencyPairQuoteValidateBeforeCall(userId, userSecret, accountId, instrumentSymbol, null);
        Type localVarReturnType = new TypeToken<CryptocurrencyPairQuote>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getCryptocurrencyPairQuoteAsync(String userId, String userSecret, UUID accountId, String instrumentSymbol, final ApiCallback<CryptocurrencyPairQuote> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCryptocurrencyPairQuoteValidateBeforeCall(userId, userSecret, accountId, instrumentSymbol, _callback);
        Type localVarReturnType = new TypeToken<CryptocurrencyPairQuote>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class GetCryptocurrencyPairQuoteRequestBuilderGenerated {
        final String userId;
        final String userSecret;
        final UUID accountId;
        final String instrumentSymbol;

        public GetCryptocurrencyPairQuoteRequestBuilderGenerated(String userId, String userSecret, UUID accountId, String instrumentSymbol) {
            this.userId = userId;
            this.userSecret = userSecret;
            this.accountId = accountId;
            this.instrumentSymbol = instrumentSymbol;
        }

        /**
         * Build call for getCryptocurrencyPairQuote
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getCryptocurrencyPairQuoteCall(userId, userSecret, accountId, instrumentSymbol, _callback);
        }


        /**
         * Execute getCryptocurrencyPairQuote request
         * @return CryptocurrencyPairQuote
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public CryptocurrencyPairQuote execute() throws ApiException {
            ApiResponse<CryptocurrencyPairQuote> localVarResp = getCryptocurrencyPairQuoteWithHttpInfo(userId, userSecret, accountId, instrumentSymbol);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getCryptocurrencyPairQuote request with HTTP info returned
         * @return ApiResponse&lt;CryptocurrencyPairQuote&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<CryptocurrencyPairQuote> executeWithHttpInfo() throws ApiException {
            return getCryptocurrencyPairQuoteWithHttpInfo(userId, userSecret, accountId, instrumentSymbol);
        }

        /**
         * Execute getCryptocurrencyPairQuote request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<CryptocurrencyPairQuote> _callback) throws ApiException {
            return getCryptocurrencyPairQuoteAsync(userId, userSecret, accountId, instrumentSymbol, _callback);
        }
    }

    /**
     * Get crypto pair quote
     * Gets a quote for the specified account. 
     * @param userId  (required)
     * @param userSecret  (required)
     * @param accountId  (required)
     * @param instrumentSymbol  (required)
     * @return GetCryptocurrencyPairQuoteRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.GetCryptocurrencyPairQuoteRequestBuilder getCryptocurrencyPairQuote(String userId, String userSecret, UUID accountId, String instrumentSymbol) throws IllegalArgumentException {
        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        if (instrumentSymbol == null) throw new IllegalArgumentException("\"instrumentSymbol\" is required but got null");
            

        return ((TradingApi) this).new GetCryptocurrencyPairQuoteRequestBuilder(userId, userSecret, accountId, instrumentSymbol);
    }
    private okhttp3.Call getOrderImpactCall(String userId, String userSecret, ManualTradeForm manualTradeForm, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = manualTradeForm;

        // create path and map variables
        String localVarPath = "/trade/impact";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOrderImpactValidateBeforeCall(String userId, String userSecret, ManualTradeForm manualTradeForm, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getOrderImpact(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling getOrderImpact(Async)");
        }

        // verify the required parameter 'manualTradeForm' is set
        if (manualTradeForm == null) {
            throw new ApiException("Missing the required parameter 'manualTradeForm' when calling getOrderImpact(Async)");
        }

        return getOrderImpactCall(userId, userSecret, manualTradeForm, _callback);

    }


    private ApiResponse<ManualTradeAndImpact> getOrderImpactWithHttpInfo(String userId, String userSecret, ManualTradeForm manualTradeForm) throws ApiException {
        okhttp3.Call localVarCall = getOrderImpactValidateBeforeCall(userId, userSecret, manualTradeForm, null);
        Type localVarReturnType = new TypeToken<ManualTradeAndImpact>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getOrderImpactAsync(String userId, String userSecret, ManualTradeForm manualTradeForm, final ApiCallback<ManualTradeAndImpact> _callback) throws ApiException {

        okhttp3.Call localVarCall = getOrderImpactValidateBeforeCall(userId, userSecret, manualTradeForm, _callback);
        Type localVarReturnType = new TypeToken<ManualTradeAndImpact>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class GetOrderImpactRequestBuilderGenerated {
        final UUID accountId;
        final ActionStrict action;
        final UUID universalSymbolId;
        final OrderTypeStrict orderType;
        final TimeInForceStrict timeInForce;
        final String userId;
        final String userSecret;
        Double price;
        Double stop;
        Double units;
        Object notionalValue;

        public GetOrderImpactRequestBuilderGenerated(UUID accountId, ActionStrict action, UUID universalSymbolId, OrderTypeStrict orderType, TimeInForceStrict timeInForce, String userId, String userSecret) {
            this.accountId = accountId;
            this.action = action;
            this.universalSymbolId = universalSymbolId;
            this.orderType = orderType;
            this.timeInForce = timeInForce;
            this.userId = userId;
            this.userSecret = userSecret;
        }

        /**
         * Set price
         * @param price The limit price for &#x60;Limit&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.GetOrderImpactRequestBuilder
         */
        public TradingApi.GetOrderImpactRequestBuilder price(Double price) {
            this.price = price;
            return (TradingApi.GetOrderImpactRequestBuilder) this;
        }
        

        /**
         * Set price
         * @param price The limit price for &#x60;Limit&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.GetOrderImpactRequestBuilder
         */
        public TradingApi.GetOrderImpactRequestBuilder price(Integer price) {
            this.price = price.doubleValue();
            return (TradingApi.GetOrderImpactRequestBuilder) this;
        }
        
        /**
         * Set stop
         * @param stop The price at which a stop order is triggered for &#x60;Stop&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.GetOrderImpactRequestBuilder
         */
        public TradingApi.GetOrderImpactRequestBuilder stop(Double stop) {
            this.stop = stop;
            return (TradingApi.GetOrderImpactRequestBuilder) this;
        }
        

        /**
         * Set stop
         * @param stop The price at which a stop order is triggered for &#x60;Stop&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.GetOrderImpactRequestBuilder
         */
        public TradingApi.GetOrderImpactRequestBuilder stop(Integer stop) {
            this.stop = stop.doubleValue();
            return (TradingApi.GetOrderImpactRequestBuilder) this;
        }
        
        /**
         * Set units
         * @param units Number of shares for the order. This can be a decimal for fractional orders. Must be &#x60;null&#x60; if &#x60;notional_value&#x60; is provided. (optional)
         * @return TradingApi.GetOrderImpactRequestBuilder
         */
        public TradingApi.GetOrderImpactRequestBuilder units(Double units) {
            this.units = units;
            return (TradingApi.GetOrderImpactRequestBuilder) this;
        }
        

        /**
         * Set units
         * @param units Number of shares for the order. This can be a decimal for fractional orders. Must be &#x60;null&#x60; if &#x60;notional_value&#x60; is provided. (optional)
         * @return TradingApi.GetOrderImpactRequestBuilder
         */
        public TradingApi.GetOrderImpactRequestBuilder units(Integer units) {
            this.units = units.doubleValue();
            return (TradingApi.GetOrderImpactRequestBuilder) this;
        }
        
        /**
         * Set notionalValue
         * @param notionalValue  (optional)
         * @return TradingApi.GetOrderImpactRequestBuilder
         */
        public TradingApi.GetOrderImpactRequestBuilder notionalValue(Object notionalValue) {
            this.notionalValue = notionalValue;
            return (TradingApi.GetOrderImpactRequestBuilder) this;
        }
        
        /**
         * Build call for getOrderImpact
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ManualTradeForm manualTradeForm = buildBodyParams();
            return getOrderImpactCall(userId, userSecret, manualTradeForm, _callback);
        }

        private ManualTradeForm buildBodyParams() {
            ManualTradeForm manualTradeForm = new ManualTradeForm();
            manualTradeForm.accountId(this.accountId);
            manualTradeForm.action(this.action);
            manualTradeForm.universalSymbolId(this.universalSymbolId);
            manualTradeForm.orderType(this.orderType);
            manualTradeForm.timeInForce(this.timeInForce);
            manualTradeForm.price(this.price);
            manualTradeForm.stop(this.stop);
            manualTradeForm.units(this.units);
            manualTradeForm.notionalValue(this.notionalValue);
            return manualTradeForm;
        }

        /**
         * Execute getOrderImpact request
         * @return ManualTradeAndImpact
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ManualTradeAndImpact execute() throws ApiException {
            ManualTradeForm manualTradeForm = buildBodyParams();
            ApiResponse<ManualTradeAndImpact> localVarResp = getOrderImpactWithHttpInfo(userId, userSecret, manualTradeForm);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getOrderImpact request with HTTP info returned
         * @return ApiResponse&lt;ManualTradeAndImpact&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ManualTradeAndImpact> executeWithHttpInfo() throws ApiException {
            ManualTradeForm manualTradeForm = buildBodyParams();
            return getOrderImpactWithHttpInfo(userId, userSecret, manualTradeForm);
        }

        /**
         * Execute getOrderImpact request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ManualTradeAndImpact> _callback) throws ApiException {
            ManualTradeForm manualTradeForm = buildBodyParams();
            return getOrderImpactAsync(userId, userSecret, manualTradeForm, _callback);
        }
    }

    /**
     * Check equity order impact
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a &#x60;Trade&#x60; object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the &#x60;Trade&#x60; object returned expires after 5 minutes. Any order placed using an expired &#x60;Trade&#x60; will be rejected.
     * @param userId  (required)
     * @param userSecret  (required)
     * @param manualTradeForm  (required)
     * @return GetOrderImpactRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.GetOrderImpactRequestBuilder getOrderImpact(UUID accountId, ActionStrict action, UUID universalSymbolId, OrderTypeStrict orderType, TimeInForceStrict timeInForce, String userId, String userSecret) throws IllegalArgumentException {
        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        if (action == null) throw new IllegalArgumentException("\"action\" is required but got null");
        if (universalSymbolId == null) throw new IllegalArgumentException("\"universalSymbolId\" is required but got null");
            

        if (orderType == null) throw new IllegalArgumentException("\"orderType\" is required but got null");
        if (timeInForce == null) throw new IllegalArgumentException("\"timeInForce\" is required but got null");
        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        return ((TradingApi) this).new GetOrderImpactRequestBuilder(accountId, action, universalSymbolId, orderType, timeInForce, userId, userSecret);
    }
    private okhttp3.Call getUserAccountQuotesCall(String userId, String userSecret, String symbols, UUID accountId, Boolean useTicker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/quotes"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        if (symbols != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbols", symbols));
        }

        if (useTicker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("use_ticker", useTicker));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserAccountQuotesValidateBeforeCall(String userId, String userSecret, String symbols, UUID accountId, Boolean useTicker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getUserAccountQuotes(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling getUserAccountQuotes(Async)");
        }

        // verify the required parameter 'symbols' is set
        if (symbols == null) {
            throw new ApiException("Missing the required parameter 'symbols' when calling getUserAccountQuotes(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling getUserAccountQuotes(Async)");
        }

        return getUserAccountQuotesCall(userId, userSecret, symbols, accountId, useTicker, _callback);

    }


    private ApiResponse<List<SymbolsQuotesInner>> getUserAccountQuotesWithHttpInfo(String userId, String userSecret, String symbols, UUID accountId, Boolean useTicker) throws ApiException {
        okhttp3.Call localVarCall = getUserAccountQuotesValidateBeforeCall(userId, userSecret, symbols, accountId, useTicker, null);
        Type localVarReturnType = new TypeToken<List<SymbolsQuotesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserAccountQuotesAsync(String userId, String userSecret, String symbols, UUID accountId, Boolean useTicker, final ApiCallback<List<SymbolsQuotesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserAccountQuotesValidateBeforeCall(userId, userSecret, symbols, accountId, useTicker, _callback);
        Type localVarReturnType = new TypeToken<List<SymbolsQuotesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class GetUserAccountQuotesRequestBuilderGenerated {
        final String userId;
        final String userSecret;
        final String symbols;
        final UUID accountId;
        Boolean useTicker;

        public GetUserAccountQuotesRequestBuilderGenerated(String userId, String userSecret, String symbols, UUID accountId) {
            this.userId = userId;
            this.userSecret = userSecret;
            this.symbols = symbols;
            this.accountId = accountId;
        }

        /**
         * Set useTicker
         * @param useTicker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
         * @return TradingApi.GetUserAccountQuotesRequestBuilder
         */
        public TradingApi.GetUserAccountQuotesRequestBuilder useTicker(Boolean useTicker) {
            this.useTicker = useTicker;
            return (TradingApi.GetUserAccountQuotesRequestBuilder) this;
        }
        
        /**
         * Build call for getUserAccountQuotes
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserAccountQuotesCall(userId, userSecret, symbols, accountId, useTicker, _callback);
        }


        /**
         * Execute getUserAccountQuotes request
         * @return List&lt;SymbolsQuotesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public List<SymbolsQuotesInner> execute() throws ApiException {
            ApiResponse<List<SymbolsQuotesInner>> localVarResp = getUserAccountQuotesWithHttpInfo(userId, userSecret, symbols, accountId, useTicker);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserAccountQuotes request with HTTP info returned
         * @return ApiResponse&lt;List&lt;SymbolsQuotesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<SymbolsQuotesInner>> executeWithHttpInfo() throws ApiException {
            return getUserAccountQuotesWithHttpInfo(userId, userSecret, symbols, accountId, useTicker);
        }

        /**
         * Execute getUserAccountQuotes request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<SymbolsQuotesInner>> _callback) throws ApiException {
            return getUserAccountQuotesAsync(userId, userSecret, symbols, accountId, useTicker, _callback);
        }
    }

    /**
     * Get equity symbol quotes
     * Returns quotes from the brokerage for the specified symbols and account.  The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint.  This endpoint does not work for options quotes.  This endpoint is disabled for free plans by default. Please contact support to enable this endpoint if needed. 
     * @param userId  (required)
     * @param userSecret  (required)
     * @param symbols List of Universal Symbol IDs or tickers to get quotes for. When providing multiple values, use a comma as separator (required)
     * @param accountId  (required)
     * @return GetUserAccountQuotesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.GetUserAccountQuotesRequestBuilder getUserAccountQuotes(String userId, String userSecret, String symbols, UUID accountId) throws IllegalArgumentException {
        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        if (symbols == null) throw new IllegalArgumentException("\"symbols\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        return ((TradingApi) this).new GetUserAccountQuotesRequestBuilder(userId, userSecret, symbols, accountId);
    }
    private okhttp3.Call placeBracketOrderCall(UUID accountId, String userId, String userSecret, ManualTradeFormBracket manualTradeFormBracket, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = manualTradeFormBracket;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/trading/bracket"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call placeBracketOrderValidateBeforeCall(UUID accountId, String userId, String userSecret, ManualTradeFormBracket manualTradeFormBracket, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling placeBracketOrder(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling placeBracketOrder(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling placeBracketOrder(Async)");
        }

        // verify the required parameter 'manualTradeFormBracket' is set
        if (manualTradeFormBracket == null) {
            throw new ApiException("Missing the required parameter 'manualTradeFormBracket' when calling placeBracketOrder(Async)");
        }

        return placeBracketOrderCall(accountId, userId, userSecret, manualTradeFormBracket, _callback);

    }


    private ApiResponse<AccountOrderRecord> placeBracketOrderWithHttpInfo(UUID accountId, String userId, String userSecret, ManualTradeFormBracket manualTradeFormBracket) throws ApiException {
        okhttp3.Call localVarCall = placeBracketOrderValidateBeforeCall(accountId, userId, userSecret, manualTradeFormBracket, null);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call placeBracketOrderAsync(UUID accountId, String userId, String userSecret, ManualTradeFormBracket manualTradeFormBracket, final ApiCallback<AccountOrderRecord> _callback) throws ApiException {

        okhttp3.Call localVarCall = placeBracketOrderValidateBeforeCall(accountId, userId, userSecret, manualTradeFormBracket, _callback);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class PlaceBracketOrderRequestBuilderGenerated {
        final ActionStrictWithOptions action;
        final TradingInstrument instrument;
        final OrderTypeStrict orderType;
        final TimeInForceStrict timeInForce;
        final StopLoss stopLoss;
        final TakeProfit takeProfit;
        final UUID accountId;
        final String userId;
        final String userSecret;
        Double price;
        Double stop;
        Double units;

        public PlaceBracketOrderRequestBuilderGenerated(ActionStrictWithOptions action, TradingInstrument instrument, OrderTypeStrict orderType, TimeInForceStrict timeInForce, StopLoss stopLoss, TakeProfit takeProfit, UUID accountId, String userId, String userSecret) {
            this.action = action;
            this.instrument = instrument;
            this.orderType = orderType;
            this.timeInForce = timeInForce;
            this.stopLoss = stopLoss;
            this.takeProfit = takeProfit;
            this.accountId = accountId;
            this.userId = userId;
            this.userSecret = userSecret;
        }

        /**
         * Set price
         * @param price The limit price for &#x60;Limit&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.PlaceBracketOrderRequestBuilder
         */
        public TradingApi.PlaceBracketOrderRequestBuilder price(Double price) {
            this.price = price;
            return (TradingApi.PlaceBracketOrderRequestBuilder) this;
        }
        

        /**
         * Set price
         * @param price The limit price for &#x60;Limit&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.PlaceBracketOrderRequestBuilder
         */
        public TradingApi.PlaceBracketOrderRequestBuilder price(Integer price) {
            this.price = price.doubleValue();
            return (TradingApi.PlaceBracketOrderRequestBuilder) this;
        }
        
        /**
         * Set stop
         * @param stop The price at which a stop order is triggered for &#x60;Stop&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.PlaceBracketOrderRequestBuilder
         */
        public TradingApi.PlaceBracketOrderRequestBuilder stop(Double stop) {
            this.stop = stop;
            return (TradingApi.PlaceBracketOrderRequestBuilder) this;
        }
        

        /**
         * Set stop
         * @param stop The price at which a stop order is triggered for &#x60;Stop&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.PlaceBracketOrderRequestBuilder
         */
        public TradingApi.PlaceBracketOrderRequestBuilder stop(Integer stop) {
            this.stop = stop.doubleValue();
            return (TradingApi.PlaceBracketOrderRequestBuilder) this;
        }
        
        /**
         * Set units
         * @param units Number of shares for the order. This can be a decimal for fractional orders. Must be &#x60;null&#x60; if &#x60;notional_value&#x60; is provided. (optional)
         * @return TradingApi.PlaceBracketOrderRequestBuilder
         */
        public TradingApi.PlaceBracketOrderRequestBuilder units(Double units) {
            this.units = units;
            return (TradingApi.PlaceBracketOrderRequestBuilder) this;
        }
        
        /**
         * Build call for placeBracketOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ManualTradeFormBracket manualTradeFormBracket = buildBodyParams();
            return placeBracketOrderCall(accountId, userId, userSecret, manualTradeFormBracket, _callback);
        }

        private ManualTradeFormBracket buildBodyParams() {
            ManualTradeFormBracket manualTradeFormBracket = new ManualTradeFormBracket();
            manualTradeFormBracket.action(this.action);
            manualTradeFormBracket.instrument(this.instrument);
            manualTradeFormBracket.orderType(this.orderType);
            manualTradeFormBracket.timeInForce(this.timeInForce);
            manualTradeFormBracket.price(this.price);
            manualTradeFormBracket.stop(this.stop);
            manualTradeFormBracket.units(this.units);
            manualTradeFormBracket.stopLoss(this.stopLoss);
            manualTradeFormBracket.takeProfit(this.takeProfit);
            return manualTradeFormBracket;
        }

        /**
         * Execute placeBracketOrder request
         * @return AccountOrderRecord
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public AccountOrderRecord execute() throws ApiException {
            ManualTradeFormBracket manualTradeFormBracket = buildBodyParams();
            ApiResponse<AccountOrderRecord> localVarResp = placeBracketOrderWithHttpInfo(accountId, userId, userSecret, manualTradeFormBracket);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute placeBracketOrder request with HTTP info returned
         * @return ApiResponse&lt;AccountOrderRecord&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<AccountOrderRecord> executeWithHttpInfo() throws ApiException {
            ManualTradeFormBracket manualTradeFormBracket = buildBodyParams();
            return placeBracketOrderWithHttpInfo(accountId, userId, userSecret, manualTradeFormBracket);
        }

        /**
         * Execute placeBracketOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<AccountOrderRecord> _callback) throws ApiException {
            ManualTradeFormBracket manualTradeFormBracket = buildBodyParams();
            return placeBracketOrderAsync(accountId, userId, userSecret, manualTradeFormBracket, _callback);
        }
    }

    /**
     * Place bracket order
     * Places a bracket order (entry order + OCO of stop loss and take profit). Disabled by default please contact support for use. Only supported on certain brokerages 
     * @param accountId The ID of the account to execute the trade on. (required)
     * @param userId  (required)
     * @param userSecret  (required)
     * @param manualTradeFormBracket  (required)
     * @return PlaceBracketOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.PlaceBracketOrderRequestBuilder placeBracketOrder(ActionStrictWithOptions action, TradingInstrument instrument, OrderTypeStrict orderType, TimeInForceStrict timeInForce, StopLoss stopLoss, TakeProfit takeProfit, UUID accountId, String userId, String userSecret) throws IllegalArgumentException {
        if (action == null) throw new IllegalArgumentException("\"action\" is required but got null");
        if (instrument == null) throw new IllegalArgumentException("\"instrument\" is required but got null");
        if (orderType == null) throw new IllegalArgumentException("\"orderType\" is required but got null");
        if (timeInForce == null) throw new IllegalArgumentException("\"timeInForce\" is required but got null");
        if (stopLoss == null) throw new IllegalArgumentException("\"stopLoss\" is required but got null");
        if (takeProfit == null) throw new IllegalArgumentException("\"takeProfit\" is required but got null");
        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        return ((TradingApi) this).new PlaceBracketOrderRequestBuilder(action, instrument, orderType, timeInForce, stopLoss, takeProfit, accountId, userId, userSecret);
    }
    private okhttp3.Call placeCryptoOrderCall(String userId, String userSecret, UUID accountId, CryptoOrderForm cryptoOrderForm, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = cryptoOrderForm;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/trading/crypto"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call placeCryptoOrderValidateBeforeCall(String userId, String userSecret, UUID accountId, CryptoOrderForm cryptoOrderForm, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling placeCryptoOrder(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling placeCryptoOrder(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling placeCryptoOrder(Async)");
        }

        // verify the required parameter 'cryptoOrderForm' is set
        if (cryptoOrderForm == null) {
            throw new ApiException("Missing the required parameter 'cryptoOrderForm' when calling placeCryptoOrder(Async)");
        }

        return placeCryptoOrderCall(userId, userSecret, accountId, cryptoOrderForm, _callback);

    }


    private ApiResponse<OrderUpdatedResponse> placeCryptoOrderWithHttpInfo(String userId, String userSecret, UUID accountId, CryptoOrderForm cryptoOrderForm) throws ApiException {
        okhttp3.Call localVarCall = placeCryptoOrderValidateBeforeCall(userId, userSecret, accountId, cryptoOrderForm, null);
        Type localVarReturnType = new TypeToken<OrderUpdatedResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call placeCryptoOrderAsync(String userId, String userSecret, UUID accountId, CryptoOrderForm cryptoOrderForm, final ApiCallback<OrderUpdatedResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = placeCryptoOrderValidateBeforeCall(userId, userSecret, accountId, cryptoOrderForm, _callback);
        Type localVarReturnType = new TypeToken<OrderUpdatedResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class PlaceCryptoOrderRequestBuilderGenerated {
        final CryptoTradingInstrument instrument;
        final ActionStrict side;
        final String type;
        final String timeInForce;
        final BigDecimal amount;
        final String userId;
        final String userSecret;
        final UUID accountId;
        BigDecimal limitPrice;
        BigDecimal stopPrice;
        Boolean postOnly;
        OffsetDateTime expirationDate;

        public PlaceCryptoOrderRequestBuilderGenerated(CryptoTradingInstrument instrument, ActionStrict side, String type, String timeInForce, BigDecimal amount, String userId, String userSecret, UUID accountId) {
            this.instrument = instrument;
            this.side = side;
            this.type = type;
            this.timeInForce = timeInForce;
            this.amount = amount;
            this.userId = userId;
            this.userSecret = userSecret;
            this.accountId = accountId;
        }

        /**
         * Set limitPrice
         * @param limitPrice The limit price. Required if the order type is LIMIT, STOP_LOSS_LIMIT or TAKE_PROFIT_LIMIT. (optional)
         * @return TradingApi.PlaceCryptoOrderRequestBuilder
         */
        public TradingApi.PlaceCryptoOrderRequestBuilder limitPrice(BigDecimal limitPrice) {
            this.limitPrice = limitPrice;
            return (TradingApi.PlaceCryptoOrderRequestBuilder) this;
        }
        
        /**
         * Set stopPrice
         * @param stopPrice The stop price. Required if the order type is STOP_LOSS_MARKET, STOP_LOSS_LIMIT, TAKE_PROFIT_MARKET or TAKE_PROFIT_LIMIT. (optional)
         * @return TradingApi.PlaceCryptoOrderRequestBuilder
         */
        public TradingApi.PlaceCryptoOrderRequestBuilder stopPrice(BigDecimal stopPrice) {
            this.stopPrice = stopPrice;
            return (TradingApi.PlaceCryptoOrderRequestBuilder) this;
        }
        
        /**
         * Set postOnly
         * @param postOnly Valid and required only for order type LIMIT. If true orders that would be filled immediately are rejected to avoid incurring TAKER fees.  (optional)
         * @return TradingApi.PlaceCryptoOrderRequestBuilder
         */
        public TradingApi.PlaceCryptoOrderRequestBuilder postOnly(Boolean postOnly) {
            this.postOnly = postOnly;
            return (TradingApi.PlaceCryptoOrderRequestBuilder) this;
        }
        
        /**
         * Set expirationDate
         * @param expirationDate The expiration date of the order. Required if the time_in_force is GTD. (optional)
         * @return TradingApi.PlaceCryptoOrderRequestBuilder
         */
        public TradingApi.PlaceCryptoOrderRequestBuilder expirationDate(OffsetDateTime expirationDate) {
            this.expirationDate = expirationDate;
            return (TradingApi.PlaceCryptoOrderRequestBuilder) this;
        }
        
        /**
         * Build call for placeCryptoOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            CryptoOrderForm cryptoOrderForm = buildBodyParams();
            return placeCryptoOrderCall(userId, userSecret, accountId, cryptoOrderForm, _callback);
        }

        private CryptoOrderForm buildBodyParams() {
            CryptoOrderForm cryptoOrderForm = new CryptoOrderForm();
            cryptoOrderForm.instrument(this.instrument);
            cryptoOrderForm.side(this.side);
            if (this.type != null)
            cryptoOrderForm.type(CryptoOrderForm.TypeEnum.fromValue(this.type));
            if (this.timeInForce != null)
            cryptoOrderForm.timeInForce(CryptoOrderForm.TimeInForceEnum.fromValue(this.timeInForce));
            cryptoOrderForm.amount(this.amount);
            cryptoOrderForm.limitPrice(this.limitPrice);
            cryptoOrderForm.stopPrice(this.stopPrice);
            cryptoOrderForm.postOnly(this.postOnly);
            cryptoOrderForm.expirationDate(this.expirationDate);
            return cryptoOrderForm;
        }

        /**
         * Execute placeCryptoOrder request
         * @return OrderUpdatedResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public OrderUpdatedResponse execute() throws ApiException {
            CryptoOrderForm cryptoOrderForm = buildBodyParams();
            ApiResponse<OrderUpdatedResponse> localVarResp = placeCryptoOrderWithHttpInfo(userId, userSecret, accountId, cryptoOrderForm);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute placeCryptoOrder request with HTTP info returned
         * @return ApiResponse&lt;OrderUpdatedResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OrderUpdatedResponse> executeWithHttpInfo() throws ApiException {
            CryptoOrderForm cryptoOrderForm = buildBodyParams();
            return placeCryptoOrderWithHttpInfo(userId, userSecret, accountId, cryptoOrderForm);
        }

        /**
         * Execute placeCryptoOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OrderUpdatedResponse> _callback) throws ApiException {
            CryptoOrderForm cryptoOrderForm = buildBodyParams();
            return placeCryptoOrderAsync(userId, userSecret, accountId, cryptoOrderForm, _callback);
        }
    }

    /**
     * Place crypto order
     * Places an order in the specified account. This endpoint does not compute the impact to the account balance from the order before submitting the order. 
     * @param userId  (required)
     * @param userSecret  (required)
     * @param accountId  (required)
     * @param cryptoOrderForm  (required)
     * @return PlaceCryptoOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.PlaceCryptoOrderRequestBuilder placeCryptoOrder(CryptoTradingInstrument instrument, ActionStrict side, String type, String timeInForce, BigDecimal amount, String userId, String userSecret, UUID accountId) throws IllegalArgumentException {
        if (instrument == null) throw new IllegalArgumentException("\"instrument\" is required but got null");
        if (side == null) throw new IllegalArgumentException("\"side\" is required but got null");
        if (type == null) throw new IllegalArgumentException("\"type\" is required but got null");
            

        if (timeInForce == null) throw new IllegalArgumentException("\"timeInForce\" is required but got null");
            

        if (amount == null) throw new IllegalArgumentException("\"amount\" is required but got null");
            

        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        return ((TradingApi) this).new PlaceCryptoOrderRequestBuilder(instrument, side, type, timeInForce, amount, userId, userSecret, accountId);
    }
    private okhttp3.Call placeForceOrderCall(String userId, String userSecret, ManualTradeFormWithOptions manualTradeFormWithOptions, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = manualTradeFormWithOptions;

        // create path and map variables
        String localVarPath = "/trade/place";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call placeForceOrderValidateBeforeCall(String userId, String userSecret, ManualTradeFormWithOptions manualTradeFormWithOptions, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling placeForceOrder(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling placeForceOrder(Async)");
        }

        // verify the required parameter 'manualTradeFormWithOptions' is set
        if (manualTradeFormWithOptions == null) {
            throw new ApiException("Missing the required parameter 'manualTradeFormWithOptions' when calling placeForceOrder(Async)");
        }

        return placeForceOrderCall(userId, userSecret, manualTradeFormWithOptions, _callback);

    }


    private ApiResponse<AccountOrderRecord> placeForceOrderWithHttpInfo(String userId, String userSecret, ManualTradeFormWithOptions manualTradeFormWithOptions) throws ApiException {
        okhttp3.Call localVarCall = placeForceOrderValidateBeforeCall(userId, userSecret, manualTradeFormWithOptions, null);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call placeForceOrderAsync(String userId, String userSecret, ManualTradeFormWithOptions manualTradeFormWithOptions, final ApiCallback<AccountOrderRecord> _callback) throws ApiException {

        okhttp3.Call localVarCall = placeForceOrderValidateBeforeCall(userId, userSecret, manualTradeFormWithOptions, _callback);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class PlaceForceOrderRequestBuilderGenerated {
        final UUID accountId;
        final ActionStrictWithOptions action;
        final OrderTypeStrict orderType;
        final TimeInForceStrict timeInForce;
        final String userId;
        final String userSecret;
        UUID universalSymbolId;
        String symbol;
        Double price;
        Double stop;
        Double units;
        Object notionalValue;

        public PlaceForceOrderRequestBuilderGenerated(UUID accountId, ActionStrictWithOptions action, OrderTypeStrict orderType, TimeInForceStrict timeInForce, String userId, String userSecret) {
            this.accountId = accountId;
            this.action = action;
            this.orderType = orderType;
            this.timeInForce = timeInForce;
            this.userId = userId;
            this.userSecret = userSecret;
        }

        /**
         * Set universalSymbolId
         * @param universalSymbolId Unique identifier for the symbol within SnapTrade. This is the ID used to reference the symbol in SnapTrade API calls. (optional)
         * @return TradingApi.PlaceForceOrderRequestBuilder
         */
        public TradingApi.PlaceForceOrderRequestBuilder universalSymbolId(UUID universalSymbolId) {
            this.universalSymbolId = universalSymbolId;
            return (TradingApi.PlaceForceOrderRequestBuilder) this;
        }
        
        /**
         * Set symbol
         * @param symbol The security&#39;s trading ticker symbol. If &#39;symbol&#39; is provided, then &#39;universal_symbol_id&#39; must be &#39;null&#39;. (optional)
         * @return TradingApi.PlaceForceOrderRequestBuilder
         */
        public TradingApi.PlaceForceOrderRequestBuilder symbol(String symbol) {
            this.symbol = symbol;
            return (TradingApi.PlaceForceOrderRequestBuilder) this;
        }
        
        /**
         * Set price
         * @param price The limit price for &#x60;Limit&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.PlaceForceOrderRequestBuilder
         */
        public TradingApi.PlaceForceOrderRequestBuilder price(Double price) {
            this.price = price;
            return (TradingApi.PlaceForceOrderRequestBuilder) this;
        }
        

        /**
         * Set price
         * @param price The limit price for &#x60;Limit&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.PlaceForceOrderRequestBuilder
         */
        public TradingApi.PlaceForceOrderRequestBuilder price(Integer price) {
            this.price = price.doubleValue();
            return (TradingApi.PlaceForceOrderRequestBuilder) this;
        }
        
        /**
         * Set stop
         * @param stop The price at which a stop order is triggered for &#x60;Stop&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.PlaceForceOrderRequestBuilder
         */
        public TradingApi.PlaceForceOrderRequestBuilder stop(Double stop) {
            this.stop = stop;
            return (TradingApi.PlaceForceOrderRequestBuilder) this;
        }
        

        /**
         * Set stop
         * @param stop The price at which a stop order is triggered for &#x60;Stop&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.PlaceForceOrderRequestBuilder
         */
        public TradingApi.PlaceForceOrderRequestBuilder stop(Integer stop) {
            this.stop = stop.doubleValue();
            return (TradingApi.PlaceForceOrderRequestBuilder) this;
        }
        
        /**
         * Set units
         * @param units For Equity orders, this represents the number of shares for the order. This can be a decimal for fractional orders. Must be &#x60;null&#x60; if &#x60;notional_value&#x60; is provided. If placing an Option order, this field represents the number of contracts to buy or sell. (e.g., 1 contract &#x3D; 100 shares). (optional)
         * @return TradingApi.PlaceForceOrderRequestBuilder
         */
        public TradingApi.PlaceForceOrderRequestBuilder units(Double units) {
            this.units = units;
            return (TradingApi.PlaceForceOrderRequestBuilder) this;
        }
        
        /**
         * Set notionalValue
         * @param notionalValue  (optional)
         * @return TradingApi.PlaceForceOrderRequestBuilder
         */
        public TradingApi.PlaceForceOrderRequestBuilder notionalValue(Object notionalValue) {
            this.notionalValue = notionalValue;
            return (TradingApi.PlaceForceOrderRequestBuilder) this;
        }
        
        /**
         * Build call for placeForceOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ManualTradeFormWithOptions manualTradeFormWithOptions = buildBodyParams();
            return placeForceOrderCall(userId, userSecret, manualTradeFormWithOptions, _callback);
        }

        private ManualTradeFormWithOptions buildBodyParams() {
            ManualTradeFormWithOptions manualTradeFormWithOptions = new ManualTradeFormWithOptions();
            manualTradeFormWithOptions.accountId(this.accountId);
            manualTradeFormWithOptions.action(this.action);
            manualTradeFormWithOptions.universalSymbolId(this.universalSymbolId);
            manualTradeFormWithOptions.symbol(this.symbol);
            manualTradeFormWithOptions.orderType(this.orderType);
            manualTradeFormWithOptions.timeInForce(this.timeInForce);
            manualTradeFormWithOptions.price(this.price);
            manualTradeFormWithOptions.stop(this.stop);
            manualTradeFormWithOptions.units(this.units);
            manualTradeFormWithOptions.notionalValue(this.notionalValue);
            return manualTradeFormWithOptions;
        }

        /**
         * Execute placeForceOrder request
         * @return AccountOrderRecord
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public AccountOrderRecord execute() throws ApiException {
            ManualTradeFormWithOptions manualTradeFormWithOptions = buildBodyParams();
            ApiResponse<AccountOrderRecord> localVarResp = placeForceOrderWithHttpInfo(userId, userSecret, manualTradeFormWithOptions);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute placeForceOrder request with HTTP info returned
         * @return ApiResponse&lt;AccountOrderRecord&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<AccountOrderRecord> executeWithHttpInfo() throws ApiException {
            ManualTradeFormWithOptions manualTradeFormWithOptions = buildBodyParams();
            return placeForceOrderWithHttpInfo(userId, userSecret, manualTradeFormWithOptions);
        }

        /**
         * Execute placeForceOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<AccountOrderRecord> _callback) throws ApiException {
            ManualTradeFormWithOptions manualTradeFormWithOptions = buildBodyParams();
            return placeForceOrderAsync(userId, userSecret, manualTradeFormWithOptions, _callback);
        }
    }

    /**
     * Place order
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
     * @param userId  (required)
     * @param userSecret  (required)
     * @param manualTradeFormWithOptions  (required)
     * @return PlaceForceOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.PlaceForceOrderRequestBuilder placeForceOrder(UUID accountId, ActionStrictWithOptions action, OrderTypeStrict orderType, TimeInForceStrict timeInForce, String userId, String userSecret) throws IllegalArgumentException {
        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        if (action == null) throw new IllegalArgumentException("\"action\" is required but got null");
        if (orderType == null) throw new IllegalArgumentException("\"orderType\" is required but got null");
        if (timeInForce == null) throw new IllegalArgumentException("\"timeInForce\" is required but got null");
        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        return ((TradingApi) this).new PlaceForceOrderRequestBuilder(accountId, action, orderType, timeInForce, userId, userSecret);
    }
    private okhttp3.Call placeMlegOrderCall(String userId, String userSecret, UUID accountId, MlegTradeForm mlegTradeForm, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = mlegTradeForm;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/trading/options"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call placeMlegOrderValidateBeforeCall(String userId, String userSecret, UUID accountId, MlegTradeForm mlegTradeForm, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling placeMlegOrder(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling placeMlegOrder(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling placeMlegOrder(Async)");
        }

        // verify the required parameter 'mlegTradeForm' is set
        if (mlegTradeForm == null) {
            throw new ApiException("Missing the required parameter 'mlegTradeForm' when calling placeMlegOrder(Async)");
        }

        return placeMlegOrderCall(userId, userSecret, accountId, mlegTradeForm, _callback);

    }


    private ApiResponse<MlegOrderResponse> placeMlegOrderWithHttpInfo(String userId, String userSecret, UUID accountId, MlegTradeForm mlegTradeForm) throws ApiException {
        okhttp3.Call localVarCall = placeMlegOrderValidateBeforeCall(userId, userSecret, accountId, mlegTradeForm, null);
        Type localVarReturnType = new TypeToken<MlegOrderResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call placeMlegOrderAsync(String userId, String userSecret, UUID accountId, MlegTradeForm mlegTradeForm, final ApiCallback<MlegOrderResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = placeMlegOrderValidateBeforeCall(userId, userSecret, accountId, mlegTradeForm, _callback);
        Type localVarReturnType = new TypeToken<MlegOrderResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class PlaceMlegOrderRequestBuilderGenerated {
        final MlegOrderTypeStrict orderType;
        final TimeInForceStrict timeInForce;
        final List<MlegLeg> legs;
        final String userId;
        final String userSecret;
        final UUID accountId;
        BigDecimal limitPrice;
        BigDecimal stopPrice;
        MlegPriceEffectStrictNullable priceEffect;

        public PlaceMlegOrderRequestBuilderGenerated(MlegOrderTypeStrict orderType, TimeInForceStrict timeInForce, List<MlegLeg> legs, String userId, String userSecret, UUID accountId) {
            this.orderType = orderType;
            this.timeInForce = timeInForce;
            this.legs = legs;
            this.userId = userId;
            this.userSecret = userSecret;
            this.accountId = accountId;
        }

        /**
         * Set limitPrice
         * @param limitPrice The limit price. Required if the order type is LIMIT, STOP_LOSS_LIMIT. (optional)
         * @return TradingApi.PlaceMlegOrderRequestBuilder
         */
        public TradingApi.PlaceMlegOrderRequestBuilder limitPrice(BigDecimal limitPrice) {
            this.limitPrice = limitPrice;
            return (TradingApi.PlaceMlegOrderRequestBuilder) this;
        }
        
        /**
         * Set stopPrice
         * @param stopPrice The stop price. Required if the order type is STOP_LOSS_MARKET, STOP_LOSS_LIMIT. (optional)
         * @return TradingApi.PlaceMlegOrderRequestBuilder
         */
        public TradingApi.PlaceMlegOrderRequestBuilder stopPrice(BigDecimal stopPrice) {
            this.stopPrice = stopPrice;
            return (TradingApi.PlaceMlegOrderRequestBuilder) this;
        }
        
        /**
         * Set priceEffect
         * @param priceEffect  (optional)
         * @return TradingApi.PlaceMlegOrderRequestBuilder
         */
        public TradingApi.PlaceMlegOrderRequestBuilder priceEffect(MlegPriceEffectStrictNullable priceEffect) {
            this.priceEffect = priceEffect;
            return (TradingApi.PlaceMlegOrderRequestBuilder) this;
        }
        
        /**
         * Build call for placeMlegOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            MlegTradeForm mlegTradeForm = buildBodyParams();
            return placeMlegOrderCall(userId, userSecret, accountId, mlegTradeForm, _callback);
        }

        private MlegTradeForm buildBodyParams() {
            MlegTradeForm mlegTradeForm = new MlegTradeForm();
            mlegTradeForm.orderType(this.orderType);
            mlegTradeForm.timeInForce(this.timeInForce);
            mlegTradeForm.limitPrice(this.limitPrice);
            mlegTradeForm.stopPrice(this.stopPrice);
            mlegTradeForm.priceEffect(this.priceEffect);
            mlegTradeForm.legs(this.legs);
            return mlegTradeForm;
        }

        /**
         * Execute placeMlegOrder request
         * @return MlegOrderResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public MlegOrderResponse execute() throws ApiException {
            MlegTradeForm mlegTradeForm = buildBodyParams();
            ApiResponse<MlegOrderResponse> localVarResp = placeMlegOrderWithHttpInfo(userId, userSecret, accountId, mlegTradeForm);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute placeMlegOrder request with HTTP info returned
         * @return ApiResponse&lt;MlegOrderResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MlegOrderResponse> executeWithHttpInfo() throws ApiException {
            MlegTradeForm mlegTradeForm = buildBodyParams();
            return placeMlegOrderWithHttpInfo(userId, userSecret, accountId, mlegTradeForm);
        }

        /**
         * Execute placeMlegOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MlegOrderResponse> _callback) throws ApiException {
            MlegTradeForm mlegTradeForm = buildBodyParams();
            return placeMlegOrderAsync(userId, userSecret, accountId, mlegTradeForm, _callback);
        }
    }

    /**
     * Place option order
     * Places a multi-leg option order. Only supported on certain option trading brokerages. https://snaptrade.notion.site/brokerages has information on brokerage trading support 
     * @param userId  (required)
     * @param userSecret  (required)
     * @param accountId  (required)
     * @param mlegTradeForm  (required)
     * @return PlaceMlegOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.PlaceMlegOrderRequestBuilder placeMlegOrder(MlegOrderTypeStrict orderType, TimeInForceStrict timeInForce, List<MlegLeg> legs, String userId, String userSecret, UUID accountId) throws IllegalArgumentException {
        if (orderType == null) throw new IllegalArgumentException("\"orderType\" is required but got null");
        if (timeInForce == null) throw new IllegalArgumentException("\"timeInForce\" is required but got null");
        if (legs == null) throw new IllegalArgumentException("\"legs\" is required but got null");
        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        return ((TradingApi) this).new PlaceMlegOrderRequestBuilder(orderType, timeInForce, legs, userId, userSecret, accountId);
    }
    private okhttp3.Call placeOrderCall(UUID tradeId, String userId, String userSecret, ValidatedTradeBody validatedTradeBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = validatedTradeBody;

        // create path and map variables
        String localVarPath = "/trade/{tradeId}"
            .replace("{" + "tradeId" + "}", localVarApiClient.escapeString(tradeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call placeOrderValidateBeforeCall(UUID tradeId, String userId, String userSecret, ValidatedTradeBody validatedTradeBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tradeId' is set
        if (tradeId == null) {
            throw new ApiException("Missing the required parameter 'tradeId' when calling placeOrder(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling placeOrder(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling placeOrder(Async)");
        }

        return placeOrderCall(tradeId, userId, userSecret, validatedTradeBody, _callback);

    }


    private ApiResponse<AccountOrderRecord> placeOrderWithHttpInfo(UUID tradeId, String userId, String userSecret, ValidatedTradeBody validatedTradeBody) throws ApiException {
        okhttp3.Call localVarCall = placeOrderValidateBeforeCall(tradeId, userId, userSecret, validatedTradeBody, null);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call placeOrderAsync(UUID tradeId, String userId, String userSecret, ValidatedTradeBody validatedTradeBody, final ApiCallback<AccountOrderRecord> _callback) throws ApiException {

        okhttp3.Call localVarCall = placeOrderValidateBeforeCall(tradeId, userId, userSecret, validatedTradeBody, _callback);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class PlaceOrderRequestBuilderGenerated {
        final UUID tradeId;
        final String userId;
        final String userSecret;
        Boolean waitToConfirm;

        public PlaceOrderRequestBuilderGenerated(UUID tradeId, String userId, String userSecret) {
            this.tradeId = tradeId;
            this.userId = userId;
            this.userSecret = userSecret;
        }

        /**
         * Set waitToConfirm
         * @param waitToConfirm Optional, defaults to true. Determines if a wait is performed to check on order status. If false, latency will be reduced but orders returned will be more likely to be of status &#x60;PENDING&#x60; as we will not wait to check on the status before responding to the request. (optional)
         * @return TradingApi.PlaceOrderRequestBuilder
         */
        public TradingApi.PlaceOrderRequestBuilder waitToConfirm(Boolean waitToConfirm) {
            this.waitToConfirm = waitToConfirm;
            return (TradingApi.PlaceOrderRequestBuilder) this;
        }
        
        /**
         * Build call for placeOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Status of order placed </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ValidatedTradeBody validatedTradeBody = buildBodyParams();
            return placeOrderCall(tradeId, userId, userSecret, validatedTradeBody, _callback);
        }

        private ValidatedTradeBody buildBodyParams() {
            ValidatedTradeBody validatedTradeBody = new ValidatedTradeBody();
            validatedTradeBody.waitToConfirm(this.waitToConfirm);
            return validatedTradeBody;
        }

        /**
         * Execute placeOrder request
         * @return AccountOrderRecord
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Status of order placed </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public AccountOrderRecord execute() throws ApiException {
            ValidatedTradeBody validatedTradeBody = buildBodyParams();
            ApiResponse<AccountOrderRecord> localVarResp = placeOrderWithHttpInfo(tradeId, userId, userSecret, validatedTradeBody);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute placeOrder request with HTTP info returned
         * @return ApiResponse&lt;AccountOrderRecord&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Status of order placed </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<AccountOrderRecord> executeWithHttpInfo() throws ApiException {
            ValidatedTradeBody validatedTradeBody = buildBodyParams();
            return placeOrderWithHttpInfo(tradeId, userId, userSecret, validatedTradeBody);
        }

        /**
         * Execute placeOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Status of order placed </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<AccountOrderRecord> _callback) throws ApiException {
            ValidatedTradeBody validatedTradeBody = buildBodyParams();
            return placeOrderAsync(tradeId, userId, userSecret, validatedTradeBody, _callback);
        }
    }

    /**
     * Place checked equity order
     * Places the previously checked order with the brokerage. The &#x60;tradeId&#x60; is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this. 
     * @param tradeId Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param userId  (required)
     * @param userSecret  (required)
     * @return PlaceOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Status of order placed </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.PlaceOrderRequestBuilder placeOrder(UUID tradeId, String userId, String userSecret) throws IllegalArgumentException {
        if (tradeId == null) throw new IllegalArgumentException("\"tradeId\" is required but got null");
            

        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        return ((TradingApi) this).new PlaceOrderRequestBuilder(tradeId, userId, userSecret);
    }
    private okhttp3.Call previewCryptoOrderCall(String userId, String userSecret, UUID accountId, CryptoOrderForm cryptoOrderForm, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = cryptoOrderForm;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/trading/crypto/preview"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call previewCryptoOrderValidateBeforeCall(String userId, String userSecret, UUID accountId, CryptoOrderForm cryptoOrderForm, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling previewCryptoOrder(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling previewCryptoOrder(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling previewCryptoOrder(Async)");
        }

        // verify the required parameter 'cryptoOrderForm' is set
        if (cryptoOrderForm == null) {
            throw new ApiException("Missing the required parameter 'cryptoOrderForm' when calling previewCryptoOrder(Async)");
        }

        return previewCryptoOrderCall(userId, userSecret, accountId, cryptoOrderForm, _callback);

    }


    private ApiResponse<CryptoOrderPreview> previewCryptoOrderWithHttpInfo(String userId, String userSecret, UUID accountId, CryptoOrderForm cryptoOrderForm) throws ApiException {
        okhttp3.Call localVarCall = previewCryptoOrderValidateBeforeCall(userId, userSecret, accountId, cryptoOrderForm, null);
        Type localVarReturnType = new TypeToken<CryptoOrderPreview>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call previewCryptoOrderAsync(String userId, String userSecret, UUID accountId, CryptoOrderForm cryptoOrderForm, final ApiCallback<CryptoOrderPreview> _callback) throws ApiException {

        okhttp3.Call localVarCall = previewCryptoOrderValidateBeforeCall(userId, userSecret, accountId, cryptoOrderForm, _callback);
        Type localVarReturnType = new TypeToken<CryptoOrderPreview>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class PreviewCryptoOrderRequestBuilderGenerated {
        final CryptoTradingInstrument instrument;
        final ActionStrict side;
        final String type;
        final String timeInForce;
        final BigDecimal amount;
        final String userId;
        final String userSecret;
        final UUID accountId;
        BigDecimal limitPrice;
        BigDecimal stopPrice;
        Boolean postOnly;
        OffsetDateTime expirationDate;

        public PreviewCryptoOrderRequestBuilderGenerated(CryptoTradingInstrument instrument, ActionStrict side, String type, String timeInForce, BigDecimal amount, String userId, String userSecret, UUID accountId) {
            this.instrument = instrument;
            this.side = side;
            this.type = type;
            this.timeInForce = timeInForce;
            this.amount = amount;
            this.userId = userId;
            this.userSecret = userSecret;
            this.accountId = accountId;
        }

        /**
         * Set limitPrice
         * @param limitPrice The limit price. Required if the order type is LIMIT, STOP_LOSS_LIMIT or TAKE_PROFIT_LIMIT. (optional)
         * @return TradingApi.PreviewCryptoOrderRequestBuilder
         */
        public TradingApi.PreviewCryptoOrderRequestBuilder limitPrice(BigDecimal limitPrice) {
            this.limitPrice = limitPrice;
            return (TradingApi.PreviewCryptoOrderRequestBuilder) this;
        }
        
        /**
         * Set stopPrice
         * @param stopPrice The stop price. Required if the order type is STOP_LOSS_MARKET, STOP_LOSS_LIMIT, TAKE_PROFIT_MARKET or TAKE_PROFIT_LIMIT. (optional)
         * @return TradingApi.PreviewCryptoOrderRequestBuilder
         */
        public TradingApi.PreviewCryptoOrderRequestBuilder stopPrice(BigDecimal stopPrice) {
            this.stopPrice = stopPrice;
            return (TradingApi.PreviewCryptoOrderRequestBuilder) this;
        }
        
        /**
         * Set postOnly
         * @param postOnly Valid and required only for order type LIMIT. If true orders that would be filled immediately are rejected to avoid incurring TAKER fees.  (optional)
         * @return TradingApi.PreviewCryptoOrderRequestBuilder
         */
        public TradingApi.PreviewCryptoOrderRequestBuilder postOnly(Boolean postOnly) {
            this.postOnly = postOnly;
            return (TradingApi.PreviewCryptoOrderRequestBuilder) this;
        }
        
        /**
         * Set expirationDate
         * @param expirationDate The expiration date of the order. Required if the time_in_force is GTD. (optional)
         * @return TradingApi.PreviewCryptoOrderRequestBuilder
         */
        public TradingApi.PreviewCryptoOrderRequestBuilder expirationDate(OffsetDateTime expirationDate) {
            this.expirationDate = expirationDate;
            return (TradingApi.PreviewCryptoOrderRequestBuilder) this;
        }
        
        /**
         * Build call for previewCryptoOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            CryptoOrderForm cryptoOrderForm = buildBodyParams();
            return previewCryptoOrderCall(userId, userSecret, accountId, cryptoOrderForm, _callback);
        }

        private CryptoOrderForm buildBodyParams() {
            CryptoOrderForm cryptoOrderForm = new CryptoOrderForm();
            cryptoOrderForm.instrument(this.instrument);
            cryptoOrderForm.side(this.side);
            if (this.type != null)
            cryptoOrderForm.type(CryptoOrderForm.TypeEnum.fromValue(this.type));
            if (this.timeInForce != null)
            cryptoOrderForm.timeInForce(CryptoOrderForm.TimeInForceEnum.fromValue(this.timeInForce));
            cryptoOrderForm.amount(this.amount);
            cryptoOrderForm.limitPrice(this.limitPrice);
            cryptoOrderForm.stopPrice(this.stopPrice);
            cryptoOrderForm.postOnly(this.postOnly);
            cryptoOrderForm.expirationDate(this.expirationDate);
            return cryptoOrderForm;
        }

        /**
         * Execute previewCryptoOrder request
         * @return CryptoOrderPreview
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public CryptoOrderPreview execute() throws ApiException {
            CryptoOrderForm cryptoOrderForm = buildBodyParams();
            ApiResponse<CryptoOrderPreview> localVarResp = previewCryptoOrderWithHttpInfo(userId, userSecret, accountId, cryptoOrderForm);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute previewCryptoOrder request with HTTP info returned
         * @return ApiResponse&lt;CryptoOrderPreview&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<CryptoOrderPreview> executeWithHttpInfo() throws ApiException {
            CryptoOrderForm cryptoOrderForm = buildBodyParams();
            return previewCryptoOrderWithHttpInfo(userId, userSecret, accountId, cryptoOrderForm);
        }

        /**
         * Execute previewCryptoOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<CryptoOrderPreview> _callback) throws ApiException {
            CryptoOrderForm cryptoOrderForm = buildBodyParams();
            return previewCryptoOrderAsync(userId, userSecret, accountId, cryptoOrderForm, _callback);
        }
    }

    /**
     * Preview crypto order
     * Previews an order using the specified account. 
     * @param userId  (required)
     * @param userSecret  (required)
     * @param accountId  (required)
     * @param cryptoOrderForm  (required)
     * @return PreviewCryptoOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.PreviewCryptoOrderRequestBuilder previewCryptoOrder(CryptoTradingInstrument instrument, ActionStrict side, String type, String timeInForce, BigDecimal amount, String userId, String userSecret, UUID accountId) throws IllegalArgumentException {
        if (instrument == null) throw new IllegalArgumentException("\"instrument\" is required but got null");
        if (side == null) throw new IllegalArgumentException("\"side\" is required but got null");
        if (type == null) throw new IllegalArgumentException("\"type\" is required but got null");
            

        if (timeInForce == null) throw new IllegalArgumentException("\"timeInForce\" is required but got null");
            

        if (amount == null) throw new IllegalArgumentException("\"amount\" is required but got null");
            

        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        return ((TradingApi) this).new PreviewCryptoOrderRequestBuilder(instrument, side, type, timeInForce, amount, userId, userSecret, accountId);
    }
    private okhttp3.Call replaceOrderCall(UUID accountId, String userId, String userSecret, ManualTradeReplaceForm manualTradeReplaceForm, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = manualTradeReplaceForm;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/trading/replace"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call replaceOrderValidateBeforeCall(UUID accountId, String userId, String userSecret, ManualTradeReplaceForm manualTradeReplaceForm, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling replaceOrder(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling replaceOrder(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling replaceOrder(Async)");
        }

        // verify the required parameter 'manualTradeReplaceForm' is set
        if (manualTradeReplaceForm == null) {
            throw new ApiException("Missing the required parameter 'manualTradeReplaceForm' when calling replaceOrder(Async)");
        }

        return replaceOrderCall(accountId, userId, userSecret, manualTradeReplaceForm, _callback);

    }


    private ApiResponse<AccountOrderRecord> replaceOrderWithHttpInfo(UUID accountId, String userId, String userSecret, ManualTradeReplaceForm manualTradeReplaceForm) throws ApiException {
        okhttp3.Call localVarCall = replaceOrderValidateBeforeCall(accountId, userId, userSecret, manualTradeReplaceForm, null);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call replaceOrderAsync(UUID accountId, String userId, String userSecret, ManualTradeReplaceForm manualTradeReplaceForm, final ApiCallback<AccountOrderRecord> _callback) throws ApiException {

        okhttp3.Call localVarCall = replaceOrderValidateBeforeCall(accountId, userId, userSecret, manualTradeReplaceForm, _callback);
        Type localVarReturnType = new TypeToken<AccountOrderRecord>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ReplaceOrderRequestBuilderGenerated {
        final String brokerageOrderId;
        final ActionStrict action;
        final OrderTypeStrict orderType;
        final TimeInForceStrict timeInForce;
        final UUID accountId;
        final String userId;
        final String userSecret;
        Double price;
        String symbol;
        Double stop;
        Double units;

        public ReplaceOrderRequestBuilderGenerated(String brokerageOrderId, ActionStrict action, OrderTypeStrict orderType, TimeInForceStrict timeInForce, UUID accountId, String userId, String userSecret) {
            this.brokerageOrderId = brokerageOrderId;
            this.action = action;
            this.orderType = orderType;
            this.timeInForce = timeInForce;
            this.accountId = accountId;
            this.userId = userId;
            this.userSecret = userSecret;
        }

        /**
         * Set price
         * @param price The limit price for &#x60;Limit&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.ReplaceOrderRequestBuilder
         */
        public TradingApi.ReplaceOrderRequestBuilder price(Double price) {
            this.price = price;
            return (TradingApi.ReplaceOrderRequestBuilder) this;
        }
        

        /**
         * Set price
         * @param price The limit price for &#x60;Limit&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.ReplaceOrderRequestBuilder
         */
        public TradingApi.ReplaceOrderRequestBuilder price(Integer price) {
            this.price = price.doubleValue();
            return (TradingApi.ReplaceOrderRequestBuilder) this;
        }
        
        /**
         * Set symbol
         * @param symbol The security&#39;s trading ticker symbol (optional)
         * @return TradingApi.ReplaceOrderRequestBuilder
         */
        public TradingApi.ReplaceOrderRequestBuilder symbol(String symbol) {
            this.symbol = symbol;
            return (TradingApi.ReplaceOrderRequestBuilder) this;
        }
        
        /**
         * Set stop
         * @param stop The price at which a stop order is triggered for &#x60;Stop&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.ReplaceOrderRequestBuilder
         */
        public TradingApi.ReplaceOrderRequestBuilder stop(Double stop) {
            this.stop = stop;
            return (TradingApi.ReplaceOrderRequestBuilder) this;
        }
        

        /**
         * Set stop
         * @param stop The price at which a stop order is triggered for &#x60;Stop&#x60; and &#x60;StopLimit&#x60; orders. (optional)
         * @return TradingApi.ReplaceOrderRequestBuilder
         */
        public TradingApi.ReplaceOrderRequestBuilder stop(Integer stop) {
            this.stop = stop.doubleValue();
            return (TradingApi.ReplaceOrderRequestBuilder) this;
        }
        
        /**
         * Set units
         * @param units Number of shares for the order. This can be a decimal for fractional orders. Must be &#x60;null&#x60; if &#x60;notional_value&#x60; is provided. (optional)
         * @return TradingApi.ReplaceOrderRequestBuilder
         */
        public TradingApi.ReplaceOrderRequestBuilder units(Double units) {
            this.units = units;
            return (TradingApi.ReplaceOrderRequestBuilder) this;
        }
        

        /**
         * Set units
         * @param units Number of shares for the order. This can be a decimal for fractional orders. Must be &#x60;null&#x60; if &#x60;notional_value&#x60; is provided. (optional)
         * @return TradingApi.ReplaceOrderRequestBuilder
         */
        public TradingApi.ReplaceOrderRequestBuilder units(Integer units) {
            this.units = units.doubleValue();
            return (TradingApi.ReplaceOrderRequestBuilder) this;
        }
        
        /**
         * Build call for replaceOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ManualTradeReplaceForm manualTradeReplaceForm = buildBodyParams();
            return replaceOrderCall(accountId, userId, userSecret, manualTradeReplaceForm, _callback);
        }

        private ManualTradeReplaceForm buildBodyParams() {
            ManualTradeReplaceForm manualTradeReplaceForm = new ManualTradeReplaceForm();
            manualTradeReplaceForm.brokerageOrderId(this.brokerageOrderId);
            manualTradeReplaceForm.action(this.action);
            manualTradeReplaceForm.orderType(this.orderType);
            manualTradeReplaceForm.timeInForce(this.timeInForce);
            manualTradeReplaceForm.price(this.price);
            manualTradeReplaceForm.symbol(this.symbol);
            manualTradeReplaceForm.stop(this.stop);
            manualTradeReplaceForm.units(this.units);
            return manualTradeReplaceForm;
        }

        /**
         * Execute replaceOrder request
         * @return AccountOrderRecord
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public AccountOrderRecord execute() throws ApiException {
            ManualTradeReplaceForm manualTradeReplaceForm = buildBodyParams();
            ApiResponse<AccountOrderRecord> localVarResp = replaceOrderWithHttpInfo(accountId, userId, userSecret, manualTradeReplaceForm);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute replaceOrder request with HTTP info returned
         * @return ApiResponse&lt;AccountOrderRecord&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<AccountOrderRecord> executeWithHttpInfo() throws ApiException {
            ManualTradeReplaceForm manualTradeReplaceForm = buildBodyParams();
            return replaceOrderWithHttpInfo(accountId, userId, userSecret, manualTradeReplaceForm);
        }

        /**
         * Execute replaceOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<AccountOrderRecord> _callback) throws ApiException {
            ManualTradeReplaceForm manualTradeReplaceForm = buildBodyParams();
            return replaceOrderAsync(accountId, userId, userSecret, manualTradeReplaceForm, _callback);
        }
    }

    /**
     * Replace order
     * Replaces an existing pending order with a new one. The way this works is brokerage dependent, but usually involves cancelling the existing order and placing a new one. The order&#39;s brokerage_order_id may or may not change, be sure to use the one returned in the response going forward. Only supported on some brokerages 
     * @param accountId The ID of the account to execute the trade on. (required)
     * @param userId  (required)
     * @param userSecret  (required)
     * @param manualTradeReplaceForm  (required)
     * @return ReplaceOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.ReplaceOrderRequestBuilder replaceOrder(String brokerageOrderId, ActionStrict action, OrderTypeStrict orderType, TimeInForceStrict timeInForce, UUID accountId, String userId, String userSecret) throws IllegalArgumentException {
        if (brokerageOrderId == null) throw new IllegalArgumentException("\"brokerageOrderId\" is required but got null");
            

        if (action == null) throw new IllegalArgumentException("\"action\" is required but got null");
        if (orderType == null) throw new IllegalArgumentException("\"orderType\" is required but got null");
        if (timeInForce == null) throw new IllegalArgumentException("\"timeInForce\" is required but got null");
        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        return ((TradingApi) this).new ReplaceOrderRequestBuilder(brokerageOrderId, action, orderType, timeInForce, accountId, userId, userSecret);
    }
    private okhttp3.Call searchCryptocurrencyPairInstrumentsCall(String userId, String userSecret, UUID accountId, String base, String quote, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{accountId}/trading/instruments/cryptocurrencyPairs"
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (userSecret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userSecret", userSecret));
        }

        if (base != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("base", base));
        }

        if (quote != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("quote", quote));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "PartnerClientId", "PartnerSignature", "PartnerTimestamp" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchCryptocurrencyPairInstrumentsValidateBeforeCall(String userId, String userSecret, UUID accountId, String base, String quote, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling searchCryptocurrencyPairInstruments(Async)");
        }

        // verify the required parameter 'userSecret' is set
        if (userSecret == null) {
            throw new ApiException("Missing the required parameter 'userSecret' when calling searchCryptocurrencyPairInstruments(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling searchCryptocurrencyPairInstruments(Async)");
        }

        return searchCryptocurrencyPairInstrumentsCall(userId, userSecret, accountId, base, quote, _callback);

    }


    private ApiResponse<TradingSearchCryptocurrencyPairInstruments200Response> searchCryptocurrencyPairInstrumentsWithHttpInfo(String userId, String userSecret, UUID accountId, String base, String quote) throws ApiException {
        okhttp3.Call localVarCall = searchCryptocurrencyPairInstrumentsValidateBeforeCall(userId, userSecret, accountId, base, quote, null);
        Type localVarReturnType = new TypeToken<TradingSearchCryptocurrencyPairInstruments200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call searchCryptocurrencyPairInstrumentsAsync(String userId, String userSecret, UUID accountId, String base, String quote, final ApiCallback<TradingSearchCryptocurrencyPairInstruments200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchCryptocurrencyPairInstrumentsValidateBeforeCall(userId, userSecret, accountId, base, quote, _callback);
        Type localVarReturnType = new TypeToken<TradingSearchCryptocurrencyPairInstruments200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SearchCryptocurrencyPairInstrumentsRequestBuilderGenerated {
        final String userId;
        final String userSecret;
        final UUID accountId;
        String base;
        String quote;

        public SearchCryptocurrencyPairInstrumentsRequestBuilderGenerated(String userId, String userSecret, UUID accountId) {
            this.userId = userId;
            this.userSecret = userSecret;
            this.accountId = accountId;
        }

        /**
         * Set base
         * @param base  (optional)
         * @return TradingApi.SearchCryptocurrencyPairInstrumentsRequestBuilder
         */
        public TradingApi.SearchCryptocurrencyPairInstrumentsRequestBuilder base(String base) {
            this.base = base;
            return (TradingApi.SearchCryptocurrencyPairInstrumentsRequestBuilder) this;
        }
        
        /**
         * Set quote
         * @param quote  (optional)
         * @return TradingApi.SearchCryptocurrencyPairInstrumentsRequestBuilder
         */
        public TradingApi.SearchCryptocurrencyPairInstrumentsRequestBuilder quote(String quote) {
            this.quote = quote;
            return (TradingApi.SearchCryptocurrencyPairInstrumentsRequestBuilder) this;
        }
        
        /**
         * Build call for searchCryptocurrencyPairInstruments
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return searchCryptocurrencyPairInstrumentsCall(userId, userSecret, accountId, base, quote, _callback);
        }


        /**
         * Execute searchCryptocurrencyPairInstruments request
         * @return TradingSearchCryptocurrencyPairInstruments200Response
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public TradingSearchCryptocurrencyPairInstruments200Response execute() throws ApiException {
            ApiResponse<TradingSearchCryptocurrencyPairInstruments200Response> localVarResp = searchCryptocurrencyPairInstrumentsWithHttpInfo(userId, userSecret, accountId, base, quote);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute searchCryptocurrencyPairInstruments request with HTTP info returned
         * @return ApiResponse&lt;TradingSearchCryptocurrencyPairInstruments200Response&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TradingSearchCryptocurrencyPairInstruments200Response> executeWithHttpInfo() throws ApiException {
            return searchCryptocurrencyPairInstrumentsWithHttpInfo(userId, userSecret, accountId, base, quote);
        }

        /**
         * Execute searchCryptocurrencyPairInstruments request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TradingSearchCryptocurrencyPairInstruments200Response> _callback) throws ApiException {
            return searchCryptocurrencyPairInstrumentsAsync(userId, userSecret, accountId, base, quote, _callback);
        }
    }

    /**
     * Get crypto pairs
     * Searches cryptocurrency pairs instruments accessible to the specified account. Both &#x60;base&#x60; and &#x60;quote&#x60; are optional. Omit both for a full list of cryptocurrency pairs. 
     * @param userId  (required)
     * @param userSecret  (required)
     * @param accountId  (required)
     * @return SearchCryptocurrencyPairInstrumentsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected Error </td><td>  -  </td></tr>
     </table>
     */
    public TradingApi.SearchCryptocurrencyPairInstrumentsRequestBuilder searchCryptocurrencyPairInstruments(String userId, String userSecret, UUID accountId) throws IllegalArgumentException {
        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
            

        if (userSecret == null) throw new IllegalArgumentException("\"userSecret\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        return ((TradingApi) this).new SearchCryptocurrencyPairInstrumentsRequestBuilder(userId, userSecret, accountId);
    }
}
