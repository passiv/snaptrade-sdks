/*
SnapTrade

Connect brokerage accounts to your app for live positions and trading

API version: 1.0.0
Contact: api@snaptrade.com
*/

// Code generated by Konfig (https://konfigthis.com); DO NOT EDIT.

package snaptrade

import (
	"encoding/json"
)

// Position Describes a single stock/ETF/crypto/mutual fund position in an account.
type Position struct {
	Symbol *PositionSymbol `json:"symbol,omitempty"`
	// The number of shares of the position. This can be fractional or integer units.
	Units NullableFloat32 `json:"units,omitempty"`
	// Last known market price for the symbol. The freshness of this price depends on the brokerage. Some brokerages provide real-time prices, while others provide delayed prices. It is recommended that you rely on your own third-party market data provider for most up to date prices.
	Price NullableFloat32 `json:"price,omitempty"`
	// The profit or loss on the position since it was opened. This is calculated as the difference between the current market value of the position and the total cost of the position. It is recommended to calculate this value using the average purchase price and the current market price yourself, instead of relying on this field.
	OpenPnl NullableFloat32 `json:"open_pnl,omitempty"`
	// Cost basis _per share_ of this position.
	AveragePurchasePrice NullableFloat32 `json:"average_purchase_price,omitempty"`
	// Deprecated, use the `units` field for both fractional and integer units going forward
	// Deprecated
	FractionalUnits NullableFloat32 `json:"fractional_units,omitempty"`
	AdditionalProperties map[string]interface{}
}

type _Position Position

// NewPosition instantiates a new Position object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewPosition() *Position {
	this := Position{}
	return &this
}

// NewPositionWithDefaults instantiates a new Position object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewPositionWithDefaults() *Position {
	this := Position{}
	return &this
}

// GetSymbol returns the Symbol field value if set, zero value otherwise.
func (o *Position) GetSymbol() PositionSymbol {
	if o == nil || isNil(o.Symbol) {
		var ret PositionSymbol
		return ret
	}
	return *o.Symbol
}

// GetSymbolOk returns a tuple with the Symbol field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Position) GetSymbolOk() (*PositionSymbol, bool) {
	if o == nil || isNil(o.Symbol) {
    return nil, false
	}
	return o.Symbol, true
}

// HasSymbol returns a boolean if a field has been set.
func (o *Position) HasSymbol() bool {
	if o != nil && !isNil(o.Symbol) {
		return true
	}

	return false
}

// SetSymbol gets a reference to the given PositionSymbol and assigns it to the Symbol field.
func (o *Position) SetSymbol(v PositionSymbol) {
	o.Symbol = &v
}

// GetUnits returns the Units field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Position) GetUnits() float32 {
	if o == nil || isNil(o.Units.Get()) {
		var ret float32
		return ret
	}
	return *o.Units.Get()
}

// GetUnitsOk returns a tuple with the Units field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Position) GetUnitsOk() (*float32, bool) {
	if o == nil {
    return nil, false
	}
	return o.Units.Get(), o.Units.IsSet()
}

// HasUnits returns a boolean if a field has been set.
func (o *Position) HasUnits() bool {
	if o != nil && o.Units.IsSet() {
		return true
	}

	return false
}

// SetUnits gets a reference to the given NullableFloat32 and assigns it to the Units field.
func (o *Position) SetUnits(v float32) {
	o.Units.Set(&v)
}
// SetUnitsNil sets the value for Units to be an explicit nil
func (o *Position) SetUnitsNil() {
	o.Units.Set(nil)
}

// UnsetUnits ensures that no value is present for Units, not even an explicit nil
func (o *Position) UnsetUnits() {
	o.Units.Unset()
}

// GetPrice returns the Price field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Position) GetPrice() float32 {
	if o == nil || isNil(o.Price.Get()) {
		var ret float32
		return ret
	}
	return *o.Price.Get()
}

// GetPriceOk returns a tuple with the Price field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Position) GetPriceOk() (*float32, bool) {
	if o == nil {
    return nil, false
	}
	return o.Price.Get(), o.Price.IsSet()
}

// HasPrice returns a boolean if a field has been set.
func (o *Position) HasPrice() bool {
	if o != nil && o.Price.IsSet() {
		return true
	}

	return false
}

// SetPrice gets a reference to the given NullableFloat32 and assigns it to the Price field.
func (o *Position) SetPrice(v float32) {
	o.Price.Set(&v)
}
// SetPriceNil sets the value for Price to be an explicit nil
func (o *Position) SetPriceNil() {
	o.Price.Set(nil)
}

// UnsetPrice ensures that no value is present for Price, not even an explicit nil
func (o *Position) UnsetPrice() {
	o.Price.Unset()
}

// GetOpenPnl returns the OpenPnl field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Position) GetOpenPnl() float32 {
	if o == nil || isNil(o.OpenPnl.Get()) {
		var ret float32
		return ret
	}
	return *o.OpenPnl.Get()
}

// GetOpenPnlOk returns a tuple with the OpenPnl field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Position) GetOpenPnlOk() (*float32, bool) {
	if o == nil {
    return nil, false
	}
	return o.OpenPnl.Get(), o.OpenPnl.IsSet()
}

// HasOpenPnl returns a boolean if a field has been set.
func (o *Position) HasOpenPnl() bool {
	if o != nil && o.OpenPnl.IsSet() {
		return true
	}

	return false
}

// SetOpenPnl gets a reference to the given NullableFloat32 and assigns it to the OpenPnl field.
func (o *Position) SetOpenPnl(v float32) {
	o.OpenPnl.Set(&v)
}
// SetOpenPnlNil sets the value for OpenPnl to be an explicit nil
func (o *Position) SetOpenPnlNil() {
	o.OpenPnl.Set(nil)
}

// UnsetOpenPnl ensures that no value is present for OpenPnl, not even an explicit nil
func (o *Position) UnsetOpenPnl() {
	o.OpenPnl.Unset()
}

// GetAveragePurchasePrice returns the AveragePurchasePrice field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Position) GetAveragePurchasePrice() float32 {
	if o == nil || isNil(o.AveragePurchasePrice.Get()) {
		var ret float32
		return ret
	}
	return *o.AveragePurchasePrice.Get()
}

// GetAveragePurchasePriceOk returns a tuple with the AveragePurchasePrice field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Position) GetAveragePurchasePriceOk() (*float32, bool) {
	if o == nil {
    return nil, false
	}
	return o.AveragePurchasePrice.Get(), o.AveragePurchasePrice.IsSet()
}

// HasAveragePurchasePrice returns a boolean if a field has been set.
func (o *Position) HasAveragePurchasePrice() bool {
	if o != nil && o.AveragePurchasePrice.IsSet() {
		return true
	}

	return false
}

// SetAveragePurchasePrice gets a reference to the given NullableFloat32 and assigns it to the AveragePurchasePrice field.
func (o *Position) SetAveragePurchasePrice(v float32) {
	o.AveragePurchasePrice.Set(&v)
}
// SetAveragePurchasePriceNil sets the value for AveragePurchasePrice to be an explicit nil
func (o *Position) SetAveragePurchasePriceNil() {
	o.AveragePurchasePrice.Set(nil)
}

// UnsetAveragePurchasePrice ensures that no value is present for AveragePurchasePrice, not even an explicit nil
func (o *Position) UnsetAveragePurchasePrice() {
	o.AveragePurchasePrice.Unset()
}

// GetFractionalUnits returns the FractionalUnits field value if set, zero value otherwise (both if not set or set to explicit null).
// Deprecated
func (o *Position) GetFractionalUnits() float32 {
	if o == nil || isNil(o.FractionalUnits.Get()) {
		var ret float32
		return ret
	}
	return *o.FractionalUnits.Get()
}

// GetFractionalUnitsOk returns a tuple with the FractionalUnits field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
// Deprecated
func (o *Position) GetFractionalUnitsOk() (*float32, bool) {
	if o == nil {
    return nil, false
	}
	return o.FractionalUnits.Get(), o.FractionalUnits.IsSet()
}

// HasFractionalUnits returns a boolean if a field has been set.
func (o *Position) HasFractionalUnits() bool {
	if o != nil && o.FractionalUnits.IsSet() {
		return true
	}

	return false
}

// SetFractionalUnits gets a reference to the given NullableFloat32 and assigns it to the FractionalUnits field.
// Deprecated
func (o *Position) SetFractionalUnits(v float32) {
	o.FractionalUnits.Set(&v)
}
// SetFractionalUnitsNil sets the value for FractionalUnits to be an explicit nil
func (o *Position) SetFractionalUnitsNil() {
	o.FractionalUnits.Set(nil)
}

// UnsetFractionalUnits ensures that no value is present for FractionalUnits, not even an explicit nil
func (o *Position) UnsetFractionalUnits() {
	o.FractionalUnits.Unset()
}

func (o Position) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if !isNil(o.Symbol) {
		toSerialize["symbol"] = o.Symbol
	}
	if o.Units.IsSet() {
		toSerialize["units"] = o.Units.Get()
	}
	if o.Price.IsSet() {
		toSerialize["price"] = o.Price.Get()
	}
	if o.OpenPnl.IsSet() {
		toSerialize["open_pnl"] = o.OpenPnl.Get()
	}
	if o.AveragePurchasePrice.IsSet() {
		toSerialize["average_purchase_price"] = o.AveragePurchasePrice.Get()
	}
	if o.FractionalUnits.IsSet() {
		toSerialize["fractional_units"] = o.FractionalUnits.Get()
	}

	for key, value := range o.AdditionalProperties {
		toSerialize[key] = value
	}

	return json.Marshal(toSerialize)
}

func (o *Position) UnmarshalJSON(bytes []byte) (err error) {
	varPosition := _Position{}

	if err = json.Unmarshal(bytes, &varPosition); err == nil {
		*o = Position(varPosition)
	}

	additionalProperties := make(map[string]interface{})

	if err = json.Unmarshal(bytes, &additionalProperties); err == nil {
		delete(additionalProperties, "symbol")
		delete(additionalProperties, "units")
		delete(additionalProperties, "price")
		delete(additionalProperties, "open_pnl")
		delete(additionalProperties, "average_purchase_price")
		delete(additionalProperties, "fractional_units")
		o.AdditionalProperties = additionalProperties
	}

	return err
}

type NullablePosition struct {
	value *Position
	isSet bool
}

func (v NullablePosition) Get() *Position {
	return v.value
}

func (v *NullablePosition) Set(val *Position) {
	v.value = val
	v.isSet = true
}

func (v NullablePosition) IsSet() bool {
	return v.isSet
}

func (v *NullablePosition) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePosition(val *Position) *NullablePosition {
	return &NullablePosition{value: val, isSet: true}
}

func (v NullablePosition) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePosition) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


